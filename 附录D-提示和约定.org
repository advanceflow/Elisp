* 附录 D 提示和约定
本章不介绍 Emacs Lisp 的其他特性。相反，它给出了如何有效利用前面章节中描述的特性的建议，并描述了 Emacs Lisp 程序员应该遵循的约定。

您可以通过在访问 Lisp 文件时运行命令 Mx checkdoc RET 来自动检查下面描述的一些约定。它不能检查所有的约定，也不是它给出的所有警告都一定与问题相对应，但值得对它们进行检查。或者，使用命令 Mx checkdoc-current-buffer RET 来检查当前缓冲区中的约定，或者当您想以批处理模式检查文件时使用命令 checkdoc-file，例如，使用由 Mx compile RET 运行的命令。

** D.1 Emacs Lisp 编码约定
以下是编写广泛使用的 Emacs Lisp 代码时应遵循的约定：

    - 简单地加载一个包不应该改变 Emacs 的编辑行为。包括一个或多个命令以启用和禁用该功能，或调用它。

    - 对于包含自定义定义的任何文件，此约定都是强制性的。如果修复此类文件以遵循此约定需要不兼容的更改，请继续进行不兼容的更改；  不要推迟它。
    - 您应该选择一个简短的词来区分您的程序与其他 Lisp 程序。程序中所有全局符号的名称，即变量、常量和函数的名称，都应以所选前缀开头。用连字符 ~-~ 将前缀与名称的其余部分分开。这种做法有助于避免名称冲突，因为 Emacs Lisp 中的所有全局变量共享相同的名称空间，并且所有函数共享另一个名称空间29。如果符号不打算被其他包使用，请使用两个连字符来分隔前缀和名称。

    - 有时，对于一个供用户使用的命令名称，如果在包的名称前缀之前加上一些单词会更方便。例如，我们的约定是列出名为 ~list-something~ 的对象的命令，例如，一个名为 ~frob~ 的包可能有一个命令 ~list-frobs~ ，而它的其他全局符号以 ~frob-~ 开头.  此外，定义函数、变量等的结构如果以 ~define-~ 开头，效果会更好，因此将名称前缀放在名称后面。

    - 此建议甚至适用于不是 Emacs Lisp 中的原语的传统 Lisp 原语的名称，例如 copy-list。信不信由你，定义复制列表的合理方法不止一种。安全起见；  附加您的名称前缀以生成类似 foo-copy-list 或 mylib-copy-list 的名称。

    - 如果您编写了一个您认为应该以特定名称添加到 Emacs 的函数，例如 twiddle-files，请不要在程序中以该名称调用它。在你的程序中调用它 mylib-twiddle-files，然后发送邮件到 'bug-gnu-emacs@gnu.org' 建议我们将它添加到 Emacs。如果我们这样做，我们可以很容易地更改名称。

    - 如果一个前缀不够用，你的包可以使用两个或三个替代的通用前缀，只要它们有意义。
    - 我们建议在新代码中启用词法绑定，并转换现有的 Emacs Lisp 代码以启用词法绑定（如果尚未启用）。请参阅使用词法绑定。
    - 在每个单独的 Lisp 文件的末尾调用提供。请参阅功能。
    - 如果一个文件需要预先加载某些其他 Lisp 程序，那么文件开头的注释应该这样说明。此外，使用 require 确保它们已加载。请参阅功能。
    - 如果文件 foo 使用另一个文件 bar 中定义的宏，但不使用 bar 中定义的任何函数或变量，则 foo 应包含以下表达式：
      #+begin_src emacs-lisp
	(eval-when-compile (require 'bar))
      #+end_src
    - 这告诉 Emacs 在字节编译 foo 之前加载 bar，以便宏定义在编译期间可用。使用 eval-when-compile 可以避免在使用 foo 的编译版本时加载 bar。它应该在文件中第一次使用宏之前调用。请参阅宏和字节编译。
    - 除非确实需要，否则避免在运行时加载其他库。如果您的文件在没有其他库的情况下根本无法工作，那么只需在顶层需要该库并完成它。但是如果你的文件包含几个独立的特性，并且只有一两个需要额外的库，那么考虑将 require 语句放在相关函数中而不是顶层。或者在需要时使用自动加载语句来加载额外的库。这样，不使用文件这些方面的人不需要加载额外的库。
    - 如果您需要 Common Lisp 扩展，请使用 cl-lib 库而不是旧的 cl 库。后一个库已被弃用，并将在未来版本的 Emacs 中删除。
    - 定义主模式时，请遵循主模式约定。请参阅主要模式约定。
    - 定义次要模式时，请遵循次要模式约定。请参阅编写次要模式的约定。
    - 如果函数的目的是告诉您某个条件是真还是假，请给函数起一个以 ~p~ 结尾的名称（代表 ~谓词~ ）。如果名称是一个单词，则只添加 ~p~ ；  如果名称是多个单词，请添加 ~-p~ 。例如 framep 和 frame-live-p。我们建议避免在布尔变量名称中使用此 -p 后缀，除非该变量绑定到谓词函数；  相反，请使用 -flag 后缀或 is-foo 之类的名称。
    - 如果变量的目的是存储单个函数，请给它一个以 ~-function~ 结尾的名称。如果变量的目的是存储函数列表（即变量是一个钩子），请遵循钩子的命名约定。请参阅挂钩。
    - 使用 unload-feature 将撤消通常通过加载功能完成的更改（例如向挂钩添加功能）。但是，如果加载功能做了一些不寻常且更复杂的事情，您可以定义一个名为 feature-unload-function 的函数，并使其撤消任何此类特殊更改。如果存在，卸载功能将自动运行此功能。请参阅卸载。
    - 为 Emacs 原语定义别名是个坏主意。通常您应该使用标准名称。别名可能有用的情况是它有助于向后兼容或可移植性。
    - 如果一个包需要定义一个别名或一个新函数以与其他版本的 Emacs 兼容，请使用包前缀命名它，而不是使用它在其他版本中出现的原始名称。这是一个来自 Gnus 的示例，它提供了许多此类兼容性问题的示例。

      #+begin_src emacs-lisp
	(defalias 'gnus-point-at-bol
	  (if (fboundp 'point-at-bol)
	      'point-at-bol
	    'line-beginning-position))
      #+end_src

    - 重新定义或建议 Emacs 原语是一个坏主意。它可能为特定程序做正确的事情，但不知道其他程序可能会因此而中断。
    - 同样，一个 Lisp 包建议另一个 Lisp 包中的函数也是一个坏主意（请参阅建议 Emacs Lisp 函数）。
    - 避免在库和包中使用 eval-after-load 和 with-eval-after-load（请参阅 Hooks for Loading）。此功能用于个人定制；  在 Lisp 程序中使用它是不干净的，因为它以在该文件中不可见的方式修改了另一个 Lisp 文件的行为。这是调试的障碍，很像建议另一个包中的函数。
    - 如果一个文件确实替换了 Emacs 的任何标准函数或库程序，文件开头的显着注释应该说明哪些函数被替换，以及替换的行为与原始的行为有何不同。
    - 定义函数或变量的构造应该是宏，而不是函数，并且它们的名称应该以 ~define-~ 开头。宏应该接收要定义为第一个参数的名称。这将帮助各种工具自动找到定义。避免在宏本身中构造名称，因为这会使这些工具感到困惑。
    - 在其他一些系统中，有选择以 ~*~ 开头和结尾的变量名的约定。我们在 Emacs Lisp 中不使用该约定，因此请不要在您的程序中使用它。（Emacs 仅将此类名称用于特殊用途的缓冲区。）如果所有库都使用相同的约定，人们会发现 Emacs 更加连贯。
    - Emacs Lisp 源文件的默认文件编码系统是 UTF-8（请参阅文本表示）。在您的程序包含非 UTF-8 字符的罕见情况下，您应该在源文件的 ~-*-~ 行或局部变量列表中指定适当的编码系统。请参阅 GNU Emacs 手册中的文件中的局部变量。
    - 使用默认缩进参数缩进文件。
    - 不要养成自己把右括号放在行上的习惯；  Lisp 程序员发现这令人不安。
    - 如果您分发副本，请在文件上贴上版权声明和复制许可声明。请参阅 Emacs 库的常规标头。

脚注
(29)

Common Lisp 风格的包系统的好处被认为不会超过成本。


** D.2 键绑定约定
    - 许多特殊的主要模式，如 Dired、Info、Compilation 和 Occur，旨在处理包含超链接的只读文本。这样的主要模式应该重新定义mouse-2和RET来跟随链接。它还应该设置一个follow-link条件，以便该链接服从mouse-1-click-follows-link。请参阅定义可点击文本。请参阅按钮，了解实现此类可点击链接的简单方法。
    - 不要将抄送字母定义为 Lisp 程序中的键。由 Cc 和一个字母（大写或小写；ASCII 或非 ASCII）组成的序列是为用户保留的；  它们是为用户保留的唯一序列，因此不要阻止它们。

    - 更改所有 Emacs 主要模式以遵守此约定是一项艰巨的工作。放弃这个约定会使这项工作白费，并给用户带来不便。请遵守。
    - 不带修饰键的功能键 F5 到 F9 也保留给用户定义。
    - 由 Cc 后跟控制字符或数字组成的序列保留用于主要模式。
    - 由 Cc 后跟 {、}、<、>、: 或 ; 组成的序列 也保留给主要模式。
    - 由 Cc 后跟任何其他 ASCII 标点或符号字符组成的序列被分配给次要模式。并非绝对禁止在主要模式中使用它们，但如果您这样做，主要模式绑定可能会不时被次要模式遮蔽。
    - 不要在任何前缀字符（包括 Cc）之后绑定 Ch。如果您不绑定 Ch，它会自动用作列出前缀字符的子命令的帮助字符。
    - 不要绑定以 ESC 结尾的键序列，除非跟随另一个 ESC。（即绑定以 ESC ESC 结尾的序列即可。）

    - 这条规则的原因是，在任何上下文中，ESC 的非前缀绑定会阻止将转义序列识别为该上下文中的功能键。
    - 同样，不要绑定以 Cg 结尾的键序列，因为这通常用于取消键序列。
    - 任何充当用户可以进入和离开的临时模式或状态的东西都应该将 ESC ESC 或 ESC ESC ESC 定义为一种退出方式。
    -
    - 对于接受普通 Emacs 命令的状态，或者更一般地说，ESC 后跟功能键或箭头键可能有意义的任何类型的状态，那么您不能定义 ESC ESC，因为这会妨碍识别 ESC 之后的转义序列。在这些状态下，您应该将 ESC ESC ESC 定义为逃生方式。否则，改为定义 ESC ESC。

** D.3 Emacs 编程技巧
遵循这些约定将使您的程序在运行时更适合 Emacs。

    - 不要在程序中使用下一行或上一行；  几乎总是，前线更方便、更可预测和更稳健。请参阅按文本行移动。
    - 不要调用设置标记的函数，除非设置标记是程序的预期功能之一。标记是用户级别的功能，因此更改标记是不正确的，除非为用户的利益提供一个值。见标记。

    - 特别是，不要使用以下任何功能：
      #+begin_src emacs-lisp
	beginning-of-buffer, end-of-buffer
	replace-string, replace-regexp
	insert-file, insert-buffer
      #+end_src

    - 如果你只是想移动点，或者替换某个字符串，或者插入一个文件或缓冲区的内容，而没有为交互式用户准备的任何其他功能，你可以用一两行简单的 Lisp 代码来替换这些功能。
    - 使用列表而不是向量，除非有特殊原因使用向量。与向量相比，Lisp 具有更多操作列表的功能，并且使用列表通常更方便。

    - 如果不需要插入或删除元素（只有列表允许），向量对于大小很大并且以随机顺序访问（不从前到后搜索）的表来说是有利的。
    - 在回显区域显示消息的推荐方法是使用消息功能，而不是 princ。见回声区。
    - 当您遇到错误情况时，调用函数错误（或信号）。函数错误不返回。请参阅如何发出错误信号。

    - 不要使用 message、throw、sleep-for 或 beep 来报告错误。
    - 错误消息应以大写字母开头，但不应以句点或其他标点符号结尾。

    - 即使 debug-on-error 为  ~nil~ ，告诉用户错误的来源有时也很有用。在这种情况下，可以在错误消息前添加一个小写的 Lisp 符号。例如，错误消息 ~Invalid input~ 可以扩展为 ~some-function: Invalid input~ 。
    - 在 minibuffer 中用 yes-or-no-p 或 y-or-np 提出的问题应该以大写字母开头并以 '?' 结尾。
    - 当您在 minibuffer 提示中提及默认值时，请将其和 ~默认~ 一词放在括号内。它应该如下所示：

      #+begin_src emacs-lisp
	Enter the answer (default 42):
      #+end_src

    - 在交互式中，如果您使用 Lisp 表达式来生成参数列表，请不要尝试为区域或位置参数提供正确的默认值。相反，如果未指定这些参数，则为这些参数提供  ~nil~ ，并在参数为  ~nil~  时让函数体计算默认值。例如，这样写：
      #+begin_src emacs-lisp
	(defun foo (pos)
	  (interactive
	   (list (if specified specified-pos)))
	  (unless pos (setq pos default-pos))
	  ...)
      #+end_src

    - 而不是这个：
      #+begin_src emacs-lisp
	(defun foo (pos)
	  (interactive
	   (list (if specified specified-pos
		     default-pos)))
	  ...)
      #+end_src

    - 这样，命令的重复将根据当前情况重新计算这些默认值。

    - 当您使用交互式规范 ~d~ 、 ~m~ 和 ~r~ 时，您无需采取此类预防措施，因为它们会在重复命令时重新计算参数值。
    - 许多需要很长时间才能执行的命令在开始时会显示类似 ~正在运行...~ 的消息，并在完成时将其更改为 ~正在运行...完成~ 。请保持这些消息的样式统一：省略号周围没有空格， ~完成~ 后没有句点。有关生成此类消息的简单方法，请参阅报告操作进度。
    - 尽量避免使用递归编辑。相反，做 Rmail e 命令所做的事情：使用一个新的本地键盘映射，其中包含一个定义为切换回旧本地键盘映射的命令。或者干脆切换到另一个缓冲区，让用户随意切换回来。请参阅递归编辑。

** D.4 快速编译代码的技巧
以下是提高字节编译 Lisp 程序执行速度的方法。

    - 分析你的程序，找出时间花在哪里。请参阅分析。
    - 尽可能使用迭代而不是递归。Emacs Lisp 中的函数调用很慢，即使一个编译函数正在调用另一个编译函数。
    - 使用原始列表搜索函数 memq、member、assq 或 assoc 甚至比显式迭代更快。重新排列数据结构以便可以使用这些原始搜索功能之一是值得的。
    - 某些内置函数在字节编译代码中进行了特殊处理，从而避免了对普通函数调用的需要。使用这些功能而不是替代品是个好主意。要查看函数是否由编译器专门处理，请检查其字节编译属性。如果该属性不为  ~nil~ ，则对该函数进行特殊处理。

    - 例如，以下输入将显示 aref 是专门编译的（请参阅对数组进行操作的函数）：

      #+begin_src emacs-lisp
	(get 'aref 'byte-compile)
	     ⇒ byte-compile-two-args

      #+end_src
      请注意，在这种情况下（以及许多其他情况），您必须首先加载定义 byte-compile 属性的 bytecomp 库。
    - 如果调用一个小函数占了程序运行时间的很大一部分，则使该函数内联。这消除了函数调用开销。由于使函数内联会降低更改程序的灵活性，因此不要这样做，除非它以足够慢的速度让用户关心速度，否则可以明显加快速度。请参阅内联函数。

** D.5 避免编译器警告的技巧
   - 尝试通过为这些变量添加虚拟 defvar 定义来避免关于未定义的自由变量的编译器警告，如下所示：

     #+begin_src emacs-lisp
       (defvar foo)
     #+end_src

   - 这样的定义除了告诉编译器不要警告该文件中变量 foo 的使用外，没有任何作用。
   - 同样，为避免编译器警告您知道将要定义的未定义函数，请使用 declare-function 语句（请参阅告诉编译器已定义函数）。
   - 如果您使用某个文件中的许多函数、宏和变量，您可以为该包添加一个 require（请参阅 require）以避免对它们产生编译警告，如下所示：

     #+begin_src emacs-lisp
       (require 'foo)
     #+end_src


   - 如果您只需要某个文件中的宏，则可以仅在编译时需要它（请参阅编译期间的评估）。例如，
     #+begin_src emacs-lisp
       (eval-when-compile
	 (require 'foo))
     #+end_src

   - 如果您在一个函数中绑定一个变量，并在另一个函数中使用或设置它，编译器会警告后一个函数，除非该变量有定义。但是如果变量有一个短名称，添加一个定义是不干净的，因为 Lisp 包不应该定义短变量名称。正确的做法是重命名此变量，以用于包中其他函数和变量的名称前缀开头。
   - 避免警告的最后手段，当你想做一些通常是错误但你知道在你的使用中没有错误的事情时，就是把它放在没有警告的地方。请参阅编译器错误。

** D.6 文档字符串提示
以下是编写文档字符串的一些提示和约定。您可以通过运行命令 Mx checkdoc-minor-mode 来检查其中的许多约定。

    - 每个供用户了解的命令、函数或变量都应该有一个文档字符串。
    - Lisp 程序的内部变量或子程序也可能有一个文档字符串。文档字符串在运行的 Emacs 中占用的空间非常小。
    - 格式化文档字符串，使其适合 80 列屏幕上的 Emacs 窗口。大多数行不超过 60 个字符是个好主意。第一行不应超过 67 个字符，否则在 apropos 的输出中会显得很糟糕。

    - 如果看起来不错，您可以填写文本。Emacs Lisp 模式将文档字符串填充到 emacs-lisp-docstring-fill-column 指定的宽度。但是，有时您可以通过小心调整换行符来使文档字符串更具可读性。如果文档字符串很长，请在部分之间使用空行。
    - 文档字符串的第一行应包含一个或两个完整的句子，它们独立作为摘要。Mx apropos 仅显示第一行，如果该行的内容不独立，则结果看起来很糟糕。特别是，第一行以大写字母开始，以句点结束。

    - 对于一个函数，第一行应该简要回答这个问题， ~这个函数做什么？~   对于一个变量，第一行应该简要回答这个问题， ~这个值是什么意思~ ？

    - 不要将文档字符串限制为一行；  使用尽可能多的行来解释如何使用函数或变量的细节。请使用完整的句子来完成文本的其余部分。
    - 当用户尝试使用禁用的命令时，Emacs 只显示其文档字符串的第一段——从第一个空行开始的所有内容。如果您愿意，您可以选择在第一个空白行之前包含哪些信息，以使此显示有用。
    - 第一行应该提到函数的所有重要参数，并且应该按照它们在函数调用中的编写顺序来提及它们。如果函数有很多参数，那么在第一行全部提到它们是不可行的；  在这种情况下，第一行应该提到前几个论点，包括最重要的论点。
    - 当函数的文档字符串提到函数参数的值时，使用大写字母的参数名称，就好像它是该值的名称一样。因此，函数 eval 的文档字符串将其第一个参数称为 ~FORM~ ，因为实际的参数名称是 form：

      #+begin_src emacs-lisp
	Evaluate FORM and return its value.
      #+end_src

    - 还要用大写字母写元句法变量，例如当您将列表或向量分解为子单元时，其中一些可能会有所不同。以下示例中的 ~KEY~ 和 ~VALUE~ 说明了这种做法：

      #+begin_src emacs-lisp
	The argument TABLE should be an alist whose elements
	have the form (KEY . VALUE).  Here, KEY is ...
      #+end_src

    - 当您在文档字符串中提及 Lisp 符号时，切勿更改其大小写。如果符号的名称是 foo，请写 ~foo~ ，而不是 ~Foo~ （这是一个不同的符号）。

    - 这似乎与编写函数参数值的策略相矛盾，但并不存在真正的矛盾；  参数值与函数用来保存值的符号不同。

    - 如果这将一个小写字母放在句子的开头并且让您烦恼，请重写句子，使符号不在它的开头。
    - 不要以空格开始或结束文档字符串。
    - 不要缩进文档字符串的后续行，以便文本在源代码中与第一行的文本对齐。这在源代码中看起来不错，但在用户查看文档时看起来很奇怪。请记住，起始双引号之前的缩进不是字符串的一部分！
    - 当文档字符串引用 Lisp 符号时，按照打印的方式编写（通常表示小写），并用弯曲的单引号 ('..') 将其括起来。有两个例外：不带标点符号的写 t 和  ~nil~ 。例如：

      #+begin_src emacs-lisp
	CODE can be ‘lambda’, nil, or t.
      #+end_src
    - 有关如何输入弯曲单引号的信息，请参阅 The GNU Emacs Manual 中的引号。

    - 文档字符串也可以使用旧的单引号约定，它引用带有重音`和撇号'的符号：`like-this'而不是'like-this'。这种较旧的约定是为现已过时的显示器设计的，其中重音和撇号是镜像。使用此约定的文档在复制到帮助缓冲区时会转换为用户的首选格式。请参阅替换文档中的键绑定。

    - 当文档字符串使用单引号符号名称时，如果符号具有函数或变量定义，帮助模式会自动创建超链接。您无需执行任何特殊操作即可使用此功能。但是，当一个符号同时具有函数定义和变量定义，并且您只想引用其中一个时，您可以通过编写单词 ~变量~ 、 ~选项~ 、 ~函数~ 或'command'，紧接在符号名称之前。（在识别这些指示词时，大小写没有区别。）例如，如果你写

      #+begin_src emacs-lisp
	This function sets the variable `buffer-file-name'.
      #+end_src

    - 那么超链接将仅引用缓冲区文件名的变量文档，而不是其函数文档。

    - 如果符号具有函数定义和/或变量定义，但与您正在记录的符号的使用无关，您可以在符号名称前写上 ~符号~ 或 ~程序~ 字样，以防止创建任何超链接.  例如，

      #+begin_src emacs-lisp
	If the argument KIND-OF-RESULT is the symbol `list',
	this function returns a list of all the objects
	that satisfy the criterion.
      #+end_src

    - 没有超链接到与此处无关的函数列表的文档。

    - 通常，没有变量文档的变量不会创建超链接。您可以通过在它们前面加上 ~变量~ 或 ~选项~ 之一来强制为这些变量创建超链接。

    - 仅当人脸名称前面或后面有 ~人脸~ 一词时，才会创建人脸的超链接。在这种情况下，即使符号也被定义为变量或函数，也只会显示面部文档。

    - 要创建指向 Info 文档的超链接，请编写 Info 节点（或锚点）的单引号名称，前面加上 ~信息节点~ 、 ~信息节点~ 、 ~信息锚点~ 或 ~信息锚点~ 。Info 文件名默认为 ~emacs~ 。例如，

      #+begin_src emacs-lisp
	See Info node `Font Lock' and Info node `(elisp)Font Lock Basics'.
      #+end_src

    - 要创建指向手册页的超链接，请编写手册页的单引号名称，前面加上 ~手册页~ 、 ~手册页~ 或 ~手册页~ 。例如，

      #+begin_src emacs-lisp
	See the man page `chmod(1)' for details.
      #+end_src

    - Info 文档总是比手册页更可取，因此请务必链接到可用的 Info 手册。例如，chmod 记录在 GNU Coreutils 手册中，因此最好链接到该手册而不是手册页。

    - 要链接到自定义组，请编写组的单引号名称，前面加上 ~自定义组~ （每个单词中的第一个字符不区分大小写）。例如，

      #+begin_src emacs-lisp
	See the customization group `whitespace' for details.
      #+end_src

    - 最后，要创建指向 URL 的超链接，请编写单引号 URL，并在前面加上 ~URL~ 。例如，

      #+begin_src emacs-lisp
	The GNU project wesite has more information (see URL
	`https://www.gnu.org/').
      #+end_src

    - 不要直接在文档字符串中编写键序列。相反，使用 '\\[...]' 构造来代表它们。例如，不要写 'C-f'，而是写结构 '\\[forward-char]'。当 Emacs 显示文档字符串时，它会替换当前绑定到 forward-char 的任何键。（这通常是 'C-f'，但如果用户移动了键绑定，它可能是其他字符。）请参阅文档中的替换键绑定。
    - 在主要模式的文档字符串中，您需要引用该模式的本地映射的键绑定，而不是全局映射。因此，在文档字符串中使用一次构造 '\\<...>' 来指定要使用的键映射。在第一次使用 '\\[...]' 之前执行此操作。'\\<...>' 中的文本应该是包含主要模式的本地键盘映射的变量的名称。

    - 每次使用 '\\[...]' 都会稍微减慢文档字符串的显示速度。如果你大量使用它们，这些微小的减速就会加起来，并且可能会变得切实可见，尤其是在慢速系统上。所以我们的建议是不要过度使用它们；例如，尽量避免在同一个文档字符串中对同一个命令使用多个引用。
    - 为保持一致性，将函数文档字符串的第一句中的动词表述为祈使句——例如，使用 ~Return the cons of A and B~ 。优先于 ~返回 A 和 B 的缺点~ 。通常在第一段的其余部分也这样做看起来不错。如果每个句子都具有指示性并具有适当的主题，则后续段落通常看起来更好。
    - 作为是或否谓词的函数的文档字符串应该以诸如 ~Return t if~ 之类的词开头，以明确指出什么构成了事实。 ~return~ 一词避免了以小写 ~t~ 开头的句子，这可能会让人分心。
    - 用主动语态而不是被动语态编写文档字符串，并且用现在时而不是将来时。例如，使用 ~返回包含 A 和 B 的列表~ 。而不是 ~将返回包含 A 和 B 的列表~ 。
    - 避免不必要地使用 ~原因~ 一词（或其等价词）。而不是 ~导致 Emacs 以粗体显示文本~ ，而只写 ~以粗体显示文本~ 。
    - 避免使用 ~iff~ （一个数学术语，意思是 ~当且仅当~ ），因为许多人不熟悉它并将其误认为是拼写错误。在大多数情况下，只需 ~如果~ 就可以明确含义。否则，请尝试找到传达含义的替代措辞。
    - 尽量避免使用诸如 ~eg~ （表示 ~for example~ ）、 ~ie~ （表示 ~that is~ ）、 ~no~ 之类的缩写。（表示 ~数字~ ）、 ~cf~ （表示 ~对比~ ）和 ~wrt~ （表示 ~相对于~ ）尽可能多地。阅读扩展版几乎总是更清晰、更容易。 30
    - 当命令仅在特定模式或情况下有意义时，请在文档字符串中提及。例如，dired-find-file 的文档是：

      #+begin_src emacs-lisp
	In Dired, visit the file or directory named on this line.
      #+end_src

    - 当您定义一个代表用户可能想要设置的选项的变量时，请使用 defcustom。请参阅定义全局变量。
    - 是或否标志的变量的文档字符串应以 ~Non-nil mean~ 之类的词开头，以明确所有非  ~nil~  值是等效的，并明确指出  ~nil~  和非  ~nil~  的含义.
    - 如果文档字符串中的一行以左括号开头，请考虑在左括号之前写一个反斜杠，如下所示：

      #+begin_src emacs-lisp
	The argument FOO can be either a number
	\(a buffer position) or a string (a file name).
      #+end_src

    - 这避免了早于 27.1 的 Emacs 版本中的错误，其中 '(' 被视为 defun 的开头（请参阅 The GNU Emacs Manual 中的 Defuns）。如果您不希望有人使用旧 Emacs 版本编辑您的代码，则有不需要这种解决方法。

脚注
(30)

我们偶尔会使用这些，但尽量不要过度使用。

** D.7 撰写注释的技巧
我们建议使用以下约定进行注释：


#+begin_src emacs-lisp
  ‘;’
#+end_src

    以单个分号 ~;~ 开头的注释都应该与源代码右侧的同一列对齐。这样的注释通常解释了该行的代码是如何工作的。例如：

    #+begin_src emacs-lisp
      (setq base-version-list                 ; There was a base
	    (assoc (substring fn 0 start-vn)  ; version to which
		   file-version-assoc-list))  ; this looks like
					      ; a subversion.
    #+end_src

#+begin_src emacs-lisp
  ‘;;’
#+end_src

    以两个分号 ~;;~ 开头的注释应该与代码的缩进级别相同。此类注释通常描述以下行的目的或此时程序的状态。例如：

    #+begin_src emacs-lisp
      (prog1 (setq auto-fill-function
		   …
		   …
	;; Update mode line.
	(force-mode-line-update)))
    #+end_src


    我们通常也使用两个分号来表示函数之外的注释。
    #+begin_src emacs-lisp
      ;; This Lisp code is run in Emacs when it is to operate as
      ;; a server for other processes.
    #+end_src

    如果一个函数没有文档字符串，它应该在函数之前有一个两个分号的注释，解释函数的作用以及如何正确调用它。准确解释每个参数的含义以及函数如何解释其可能值。不过，最好将此类注释转换为文档字符串。
#+begin_src emacs-lisp
  ‘;;;’
#+end_src

    以三个（或更多）分号 ~;;;~ 开头的注释应该从左边距开始。我们将它们用于应被大纲次要模式视为标题的注释。默认情况下，以至少三个分号开头的注释（后跟一个空格和一个非空白字符）被视为节标题，以两个或更少开头的注释不是。

    （从历史上看，三分号注释也被用于注释掉函数中的行，但不鼓励使用这种用法，而是只使用两个分号。这也适用于注释掉整个函数；这样做时也使用两个分号。 )

    三个分号用于顶级部分，四个用于子部分，五个用于子子部分，依此类推。

    通常库至少有四个顶级部分。例如，当所有这些部分的主体都被隐藏时：
    #+begin_src emacs-lisp
      ;;; backquote.el --- implement the ` Lisp construct...
      ;;; Commentary:...
      ;;; Code:...
      ;;; backquote.el ends here
    #+end_src

    （从某种意义上说，最后一行不是节标题，因为它后面不能有任何文本；毕竟它标志着文件的结尾。）

    对于较长的库，建议将代码拆分为多个部分。这可以通过将 ~代码：~ 部分拆分为多个子部分来完成。尽管长期以来这是唯一推荐的方法，但许多人还是选择使用多个顶级代码段。您可以选择任何一种风格。

    使用多个顶级代码段的优点是可以避免引入额外的嵌套级别，但这也意味着名为 ~代码~ 的段不包含所有代码，这很尴尬。为避免这种情况，您不应该在该部分中放置任何代码；这样，它可以被视为分隔符而不是节标题。

    最后，我们建议您不要以冒号或任何其他标点符号结束标题。由于历史原因， ~代码：~ 和 ~注释：~ 标题以冒号结尾，但我们建议您不要对其他标题执行相同操作。

一般来说，M-；(comment-dwim) 命令自动启动适当类型的注释；或将现有注释缩进到正确的位置，具体取决于分号的数量。请参阅 GNU Emacs 手册中的操作注释。

** D.8 Emacs 库的常规头文件
Emacs 有在 Lisp 库中使用特殊注释的约定，将它们划分为多个部分并提供诸如谁编写它们的信息。对这些项目使用标准格式使工具（和人员）更容易提取相关信息。本节从一个示例开始解释这些约定：

#+begin_src emacs-lisp
  ;;; foo.el --- Support for the Foo programming language  -*- lexical-binding: t; -*-

  ;; Copyright (C) 2010-2021 Your Name


  ;; Author: Your Name <yourname@example.com>
  ;; Maintainer: Someone Else <someone@example.com>
  ;; Created: 14 Jul 2010

  ;; Keywords: languages
  ;; URL: https://example.com/foo

  ;; This file is not part of GNU Emacs.

  ;; This file is free software…
  …
  ;; along with this file.  If not, see <https://www.gnu.org/licenses/>.

#+end_src

第一行应该有这种格式：

#+begin_src emacs-lisp
  ;;; filename --- description  -*- lexical-binding: t; -*-
#+end_src

描述应包含在一行中。如果文件需要在 '-*-' 规范中设置更多变量，请在词法绑定之后添加。如果这会使第一行太长，请在文件末尾使用局部变量部分。

版权声明通常会列出您的姓名（如果您编写了文件）。如果您的雇主声称对您的作品拥有版权，您可能需要将其列出。不要说版权所有者是自由软件基金会（或该文件是 GNU Emacs 的一部分），除非您的文件已被 Emacs 发行版接受。有关版权和许可声明形式的更多信息，请参阅 GNU 网站上的指南。

版权声明之后是几行标题注释行，每行都以';;;开头。标题名称：'。以下是 header-name 的常规可能性表：

#+begin_src emacs-lisp
  ‘Author’
#+end_src

    此标头至少说明了该库的主要作者的姓名和电子邮件地址。如果有多个作者，请在以 ;; 开头的续行中列出他们。和一个制表符或至少两个空格。我们建议包括一个联系电子邮件地址，格式为 ~<...>~ 。例如：
    #+begin_src emacs-lisp
    ;;  作者：你的名字 <yourname@example.com>
    ;;  其他人 <someone@example.com>
    ;;  另一个人 <another@example.com>
    #+end_src

#+begin_src emacs-lisp
  ‘Maintainer’
#+end_src

    此标头与作者标头具有相同的格式。它列出了当前维护文件的人员（响应错误报告等）。

    如果没有维护者标头，则假定作者标头中的人是维护者。Emacs 中的一些文件使用 'emacs-devel@gnu.org' 作为维护者，这意味着作者不再对文件负责，并且它作为 Emacs 的一部分进行维护。
#+begin_src emacs-lisp
  ‘Created’
#+end_src

    此可选行给出文件的原始创建日期，仅用于历史兴趣。
#+begin_src emacs-lisp
  ‘Version’
#+end_src

    如果你想记录单个 Lisp 程序的版本号，把它们放在这一行。与 Emacs 一起分发的 Lisp 文件通常没有 ~版本~ 标头，因为 Emacs 本身的版本号用于相同的目的。如果您要分发多个文件的集合，我们建议不要在每个文件中编写版本，而只在主要文件中编写。
#+begin_src emacs-lisp
  ‘Keywords’ ¶
#+end_src

    此行列出了 finder-by-keyword 帮助命令的关键字。请使用该命令查看有意义的关键字列表。命令 Mx checkdoc-package-keywords RET 将查找并显示任何不在 finder-known-keywords 中的关键字。如果您将变量 checkdoc-package-keywords-flag 设置为非  ~nil~ ，则 checkdoc 命令将在其检查中包含关键字验证。

    此字段是人们在按主题查找内容时如何找到您的包裹的方式。要分隔关键字，您可以使用空格、逗号或同时使用两者。

    这个字段的名字是不幸的，因为人们通常认为它是编写描述其包的任意关键字的地方，而不仅仅是相关的 Finder 关键字。
#+begin_src emacs-lisp
  ‘URL’
#+end_src
#+begin_src emacs-lisp
  ‘Homepage’
#+end_src

    这些行说明了图书馆的网站。
#+begin_src emacs-lisp
  ‘Package-Version’
#+end_src

    如果'Version'不适合包管理器使用，那么一个包可以定义'Package-Version'；它将被使用。如果 'Version' 是 RCS id 或其他无法由 version-to-list 解析的东西，这很方便。请参阅包装基础知识。
#+begin_src emacs-lisp
  ‘Package-Requires’
#+end_src

    如果存在，它会命名当前包依赖于正确操作的包。请参阅包装基础知识。包管理器在下载时（以确保下载完整的包集）和激活时（以确保仅在包的所有依赖项都已激活时才激活包）都使用它。

    它的格式是单行的列表列表。每个子列表的汽车是一个包的名称，作为一个符号。每个子列表的 cadr 是可接受的最小版本号，作为可以由 version-to-list 解析的字符串。缺少版本的条目（即，只是一个符号或一个元素的子列表的条目）等同于具有版本 ~0~ 的条目。例如：

    #+begin_src emacs-lisp
      ;; Package-Requires: ((gnus "1.0") (bubbles "2.7.2") cl-lib (seq))
    #+end_src

    包代码自动定义一个名为 ~emacs~ 的包，其中包含当前运行的 Emacs 的版本号。这可用于要求包的 Emacs 最低版本。

几乎每个 Lisp 库都应该有 'Author' 和 'Keywords' 标题注释行。如果合适，请使用其他。您也可以将标题行与其他标题名称一起放入 - 它们没有标准含义，因此它们不会造成任何伤害。

我们使用额外的风格化注释来细分库文件的内容。这些应该通过空行与其他任何内容分开。这是他们的表格：

#+begin_src emacs-lisp
  ‘;;; Commentary:’
#+end_src

    这开始介绍性注释，解释图书馆如何工作。它应该紧跟在复制权限之后，由 ~更改日志~ 、 ~历史~ 或 ~代码~ 注释行终止。该文本由 Finder 包使用，因此在该上下文中应该是有意义的。
#+begin_src emacs-lisp
  ‘;;; Change Log:’
#+end_src

    这将开始一个可选的文件随时间变化的日志。不要在本节中提供太多信息——最好将详细日志保存在版本控制系统（如 Emacs 所做的那样）或单独的 ChangeLog 文件中。 ~历史~ 是 ~更改日志~ 的替代品。
#+begin_src emacs-lisp
  ‘;;; Code:’
#+end_src

    这开始了程序的实际代码。
#+begin_src emacs-lisp
  ‘;;; filename ends here’
#+end_src

    这是页脚线；它出现在文件的最后。其目的是使人们能够通过缺少页脚行来检测文件的截断版本。
