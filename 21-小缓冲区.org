* 21 小缓冲区
minibuffer 是一个特殊的缓冲区，Emacs 命令用来读取比单个数字前缀参数更复杂的参数。这些参数包括文件名、缓冲区名和命令名（如在 Mx 中）。minibuffer 显示在帧的底行，与回声区域在同一位置（请参阅回声区域），但仅当它用于读取参数时。

** 21.1 Minibuffers 简介
在大多数情况下，minibuffer 是一个普通的 Emacs 缓冲区。缓冲区中的大多数操作，例如编辑命令，都在微型缓冲区中正常工作。但是，许多管理缓冲区的操作不适用于小缓冲区。minibuffer 的名称始终采用 ~*Minibuf-number*~ 形式，并且不能更改。Minibuffers 仅显示在仅用于 minibuffers 的特殊窗口中；  这些窗口总是出现在框架的底部。（有时帧没有 minibuffer 窗口，有时一种特殊的帧只包含一个 minibuffer 窗口；请参阅 Minibuffers 和 Frames。）

minibuffer 中的文本总是以提示字符串开头，该文本由使用 minibuffer 的程序指定，以告诉用户要键入哪种类型的输入。此文本被标记为只读，因此您不会意外删除或更改它。它也被标记为一个字段（请参阅定义和使用字段），以便某些运动功能，包括行首、前向词、前向句子和前向段落，停止在提示符和实际文字。

minibuffer 的窗口通常是一行；  如果内容需要更多空间，它会自动增长。当 minibuffer 处于活动状态时，您可以使用窗口调整命令显式地临时调整其窗口大小；  当 minibuffer 退出时，窗口恢复到正常大小。当 minibuffer 未激活时，您可以通过使用框架的另一个窗口中的窗口大小调整命令或用鼠标拖动模式线来永久调整其窗口大小。（由于当前实现的细节，resize-mini-windows 必须为  ~nil~ 。）如果框架只包含一个 minibuffer 窗口，你可以通过改变框架的大小来改变它的大小。

使用 minibuffer 读取输入事件，这会改变变量的值，例如 this-command 和 last-command（请参阅命令循环中的信息）。如果您不想更改它们，您的程序应该将它们绑定在使用 minibuffer 的代码周围。

在某些情况下，即使存在活动的 minibuffer，命令也可以使用 minibuffer；这样的 minibuffer 称为递归 minibuffer。第一个 minibuffer 被命名为 '*Minibuf-1*'。递归小缓冲区通过增加名称末尾的数字来命名。（名称以空格开头，这样它们就不会出现在正常的缓冲区列表中。）在几个递归小缓冲区中，最里面的（或最近进入的）是活动的小缓冲区——你可以通过键入 RET ( exit-minibuffer) 中。我们通常称它为 minibuffer。您可以通过设置变量 enable-recursive-minibuffers 或将该名称的属性放在命令符号上来允许或禁止递归 minibuffers（请参阅 Recursive Minibuffers。）

与其他缓冲区一样，迷你缓冲区使用本地键映射（请参阅键映射）来指定特殊键绑定。调用 minibuffer 的函数还根据要完成的工作设置其本地映射。有关未完成的 minibuffer 本地映射，请参阅Reading Text Strings with the Minibuffer。有关完成的小缓冲区本地映射，请参阅执行完成的小缓冲区命令。

一个活动的 minibuffer 通常有主模式 minibuffer-mode。这是没有任何特殊功能的 Emacs 内部模式。要自定义 minibuffer 的设置，我们建议您使用 minibuffer-setup-hook（参见 Minibuffer Miscellany）而不是 minibuffer-mode-hook，因为前者在 minibuffer 完全初始化后稍后运行。

当一个 minibuffer 处于非活动状态时，它的主要模式是 minibuffer-inactive-mode，带有键盘映射 minibuffer-inactive-mode-map。仅当 minibuffer 位于单独的帧中时，这才真正有用。请参阅小缓冲区和帧。

当 Emacs 以批处理模式运行时，任何从 minibuffer 读取的请求实际上都会从 Emacs 启动时提供的标准输入描述符中读取一行。这仅支持基本输入：在批处理模式下没有任何特殊的 minibuffer 功能（历史、完成等）可用。

** 21.2 用 Minibuffer 读取文本字符串
minibuffer 输入最基本的原语是 read-from-minibuffer，它可以用来读取文本形式的字符串或 Lisp 对象。函数 read-regexp 用于读取正则表达式（参见正则表达式），这是一种特殊的字符串。还有用于读取命令、变量、文件名等的专用函数（参见完成）。

在大多数情况下，您不应该在 Lisp 函数的中间调用 minibuffer 输入函数。相反，在交互式规范中，将所有 minibuffer 输入作为读取命令参数的一部分。请参阅定义命令。

#+begin_src emacs-lisp
  Function: read-from-minibuffer prompt &optional initial keymap read history default inherit-input-method ¶
#+end_src

    此函数是从 minibuffer 获取输入的最通用方法。默认情况下，它接受任意文本并将其作为字符串返回；但是，如果 read 不为零，则它使用 read 将文本转换为 Lisp 对象（请参阅输入函数）。

    这个函数做的第一件事是激活一个小缓冲区并以提示符（必须是一个字符串）作为提示符显示它。然后用户可以在 minibuffer 中编辑文本。

    当用户键入命令退出 minibuffer 时，read-from-minibuffer 从 minibuffer 中的文本构造返回值。通常它会返回一个包含该文本的字符串。但是，如果 read 不是  ~nil~ ，read-from-minibuffer 会读取文本并返回结果 Lisp 对象，未计算。（有关阅读的信息，请参阅输入函数。）

    参数 default 指定通过历史命令可用的默认值。它应该是一个字符串、一个字符串列表或  ~nil~ 。字符串或字符串成为 minibuffer 的 ~未来历史~ ，用户可以使用 Mn。

    如果 read 不为  ~nil~ ，则如果用户输入空输入，则 default 也用作要读取的输入。如果 default 是字符串列表，则第一个字符串用作输入。如果默认值为  ~nil~ ，则空输入会导致文件结束错误。但是，在通常情况下（read 为  ~nil~ ），当用户输入空输入并返回空字符串 ~~ 时，从 minibuffer 读取会忽略默认值。在这方面，它不同于本章中的所有其他 minibuffer 输入函数。

    如果 keymap 不为零，则该 keymap 是要在 minibuffer 中使用的本地 keymap。如果 keymap 省略或为零，则 minibuffer-local-map 的值用作 keymap。指定 keymap 是为各种应用程序（例如完成）自定义 minibuffer 的最重要方法。

    参数 history 指定了一个历史列表变量，用于保存输入和 minibuffer 中使用的历史命令。它默认为 minibuffer-history。如果历史是符号 t，则不记录历史。您也可以选择在历史列表中指定起始位置。请参阅小缓冲区历史记录。

    如果变量 minibuffer-allow-text-properties 不为  ~nil~ ，则返回的字符串包括 minibuffer 中存在的任何文本属性。否则，当返回值时，所有文本属性都会被剥离。

    minibuffer-prompt-properties 中的文本属性应用于提示。默认情况下，此属性列表定义用于提示的面。此面（如果存在）将应用于面列表的末尾并在显示前合并。

    如果用户想要完全控制提示的外观，最方便的方法是在所有面列表的末尾指定默认面。例如：

    #+begin_src emacs-lisp
      (read-from-minibuffer
       (concat
	(propertize "Bold" 'face '(bold default))
	(propertize " and normal: " 'face '(default))))
    #+end_src

    如果参数inherit-input-method 不为 ~nil~ ，那么minibuffer 会继承当前输入法（参见Input Methods）和enable-multibyte-characters 的设置（参见Text Representations）从进入minibuffer 之前的当前缓冲区。

    不推荐使用 initial ；我们建议仅在为历史指定 cons 单元格的同时使用非  ~nil~  值。请参阅初始输入。

#+begin_src emacs-lisp
  Function: read-string prompt &optional initial history default inherit-input-method ¶
#+end_src

    这个函数从 minibuffer 中读取一个字符串并返回它。参数 prompt、initial、history 和 inherit-input-method 与 read-from-minibuffer 一样使用。使用的键映射是 minibuffer-local-map。

    可选参数 default 在 read-from-minibuffer 中使用，除了如果非零，它还指定用户输入空输入时返回的默认值。就像在 read-from-minibuffer 中一样，它应该是一个字符串、一个字符串列表或  ~nil~ ，相当于一个空字符串。当 default 是一个字符串时，该字符串是默认值。当它是一个字符串列表时，第一个字符串是默认值。（所有这些字符串都可以在 ~未来的 minibuffer 历史~ 中供用户使用。）

    此函数通过调用 read-from-minibuffer 函数来工作：
    #+begin_src emacs-lisp
      (read-string prompt initial history default inherit)
      ≡
      (let ((value
	     (read-from-minibuffer prompt initial nil nil
				   history default inherit)))
	(if (and (equal value "") default)
	    (if (consp default) (car default) default)
	  value))
    #+end_src

#+begin_src emacs-lisp
  Function: read-regexp prompt &optional defaults history ¶
#+end_src

    此函数从 minibuffer 中读取一个正则表达式作为字符串并返回它。如果 minibuffer 提示字符串 prompt 不以 ':' 结尾（后跟可选空格），则函数添加 ':' 到末尾，前面是默认返回值（见下文），如果那是非空的。

    可选参数 defaults 控制用户输入 null 输入时返回的默认值，并且应该是以下之一：字符串； ~nil~ ，相当于一个空字符串；字符串列表；或一个符号。

    如果 defaults 是一个符号，read-regexp 会查询变量 read-regexp-defaults-function 的值（见下文），如果它不是  ~nil~ ，则优先使用它而不是默认值。这种情况下的值应该是：

	 - regexp-history-last，这意味着使用适当的 minibuffer 历史列表的第一个元素（见下文）。
	 - 没有参数的函数，其返回值（应该是  ~nil~ 、字符串或字符串列表）成为默认值。

    read-regexp 现在确保处理默认值的结果是一个列表（即，如果值为  ~nil~  或字符串，它会将其转换为一个元素的列表）。在这个列表中，read-regexp 会附加一些可能有用的候选输入。这些都是：

	 - 点的单词或符号。
	 - 增量搜索中使用的最后一个正则表达式。
	 - 增量搜索中使用的最后一个字符串。
	 - 查询替换命令中使用的最后一个字符串或模式。

    该函数现在有一个正则表达式列表，它传递给 read-from-minibuffer 以获取用户的输入。列表的第一个元素是空输入时的默认结果。列表中的所有元素都可以作为 ~future minibuffer history~ 列表供用户使用（参见 GNU Emacs 手册中的 future 列表）。

    可选参数历史，如果非零，是一个符号，指定要使用的小缓冲区历史列表（请参阅小缓冲区历史）。如果省略或为零，历史列表默认为 regexp-history。

#+begin_src emacs-lisp
  User Option: read-regexp-defaults-function ¶
#+end_src

    函数 read-regexp 可以使用这个变量的值来确定它的默认正则表达式列表。如果非零，则此变量的值应为：

	 - 符号 regexp-history-last。
	 - 一个没有参数的函数，它返回  ~nil~ 、字符串或字符串列表。

    有关如何使用这些值的详细信息，请参阅上面的 read-regexp。

#+begin_src emacs-lisp
  Variable: minibuffer-allow-text-properties ¶
#+end_src

    如果此变量为  ~nil~ ，则 read-from-minibuffer 和 read-string 在返回之前从 minibuffer 输入中去除所有文本属性。然而，read-no-blanks-input（见下文），以及 read-minibuffer 和相关函数（见Reading Lisp Objects With the Minibuffer），以及所有完成 minibuffer 输入的函数，无条件移除 face 属性，不管这个变量的值。

    如果此变量不为  ~nil~ ，则完成表中字符串的大多数文本属性都将保留——但仅保留在已完成的部分字符串上。
    #+begin_src emacs-lisp
      (let ((minibuffer-allow-text-properties t))
	(completing-read "String: " (list (propertize "foobar" 'data 'zot))))
      => #("foobar" 3 6 (data zot))
    #+end_src


    在此示例中，用户键入 ~foo~ ，然后按 TAB 键，因此仅保留最后三个字符的文本属性。

#+begin_src emacs-lisp
  Variable: minibuffer-local-map ¶
#+end_src

    这是用于从 minibuffer 中读取的默认本地键映射。默认情况下，它进行以下绑定：

    Cj

	 退出小缓冲区
    RET

	 退出小缓冲区
    M-<

	 minibuffer-beginning-of-buffer
    CG

	 中止递归编辑
    锰
    向下

	 下一个历史元素
    国会议员
    向上

	 以前的历史元素
    小姐

	 下一个匹配历史元素
    先生

	 先前匹配的历史元素

#+begin_src emacs-lisp
  Function: read-no-blanks-input prompt &optional initial inherit-input-method ¶
#+end_src

    此函数从 minibuffer 中读取字符串，但不允许空白字符作为输入的一部分：相反，这些字符会终止输入。参数prompt、initial 和inherit-input-method 用于read-from-minibuffer。

    这是 read-from-minibuffer 函数的简化接口，并将 minibuffer-local-ns-map 键映射的值作为该函数的键映射参数传递。由于 keymap minibuffer-local-ns-map 不会重新绑定 Cq，因此可以通过引用将空格放入字符串中。

    无论 minibuffer-allow-text-properties 的值如何，此函数都会丢弃文本属性。

    #+begin_src emacs-lisp
      (read-no-blanks-input prompt initial)
      ≡
      (let (minibuffer-allow-text-properties)
	(read-from-minibuffer prompt initial minibuffer-local-ns-map))
    #+end_src

#+begin_src emacs-lisp
  Variable: minibuffer-local-ns-map ¶
#+end_src

    这个内置变量是在函数 read-no-blanks-input 中用作 minibuffer 本地键映射的键映射。默认情况下，除了 minibuffer-local-map 之外，它还会进行以下绑定：

#+begin_src emacs-lisp
  SPC ¶
#+end_src

	 退出小缓冲区
#+begin_src emacs-lisp
  TAB ¶
#+end_src

	 退出小缓冲区
#+begin_src emacs-lisp
  ? ¶
#+end_src

	 自插入退出

#+begin_src emacs-lisp
  Function: format-prompt prompt default &rest format-args ¶
#+end_src

    根据 minibuffer-default-prompt-format 变量使用默认值 default 格式化提示。

    minibuffer-default-prompt-format 是一个格式字符串（默认为 '" (default %s)"' ，它表示提示中的 ~默认~ 位如 '"Local filename (default somefile): "' 将如何被格式化。

    为了允许用户自定义其显示方式，提示用户输入值（并具有默认值）的代码应类似于以下代码片段：

    #+begin_src emacs-lisp
      (read-file-name
       (format-prompt "Local filename" file)
       nil file)
    #+end_src

    如果 format-args 为  ~nil~ ，则将 prompt 用作文字字符串。如果 format-args 不为零，则将 prompt 用作格式控制字符串，并将 prompt 和 format-args 传递给 format（请参阅格式化字符串）。

    minibuffer-default-prompt-format 可以是 '""'，在这种情况下不显示默认值。

    如果 default 为  ~nil~ ，则没有默认值，因此结果值中不包含 ~默认值~ 字符串。如果 default 是非  ~nil~  列表，则在提示中使用列表的第一个元素。

#+begin_src emacs-lisp
  Variable: read-minibuffer-restore-windows ¶
#+end_src

    如果此选项为非  ~nil~ （默认值），则从 minibuffer 获取输入将在退出时恢复输入 minibuffer 的帧的窗口配置，如果不同，则恢复拥有 minibuffer 窗口的帧。这意味着，例如，如果用户在同一帧上从 minibuffer 获取输入时拆分窗口，则在退出 minibuffer 时该拆分将被撤消。

    如果此选项为零，则不进行此类恢复。因此，上面提到的窗口拆分将在退出 minibuffer 后持续存在。

** 21.3 用 Minibuffer 读取 Lisp 对象
本节介绍使用 minibuffer 读取 Lisp 对象的函数。

#+begin_src emacs-lisp
  Function: read-minibuffer prompt &optional initial ¶
#+end_src

    这个函数使用 minibuffer 读取一个 Lisp 对象，并返回它而不评估它。参数 prompt 和 initial 与 read-from-minibuffer 一样使用。

    这是 read-from-minibuffer 函数的简化接口：

    #+begin_src emacs-lisp
(read-minibuffer prompt initial)
≡
(let (minibuffer-allow-text-properties)
  (read-from-minibuffer prompt initial nil t))
    #+end_src

    这是一个示例，其中我们提供字符串 ~(testing)~ 作为初始输入：
    #+begin_src emacs-lisp


      (read-minibuffer
       "Enter an expression: " (format "%s" '(testing)))

      ;; Here is how the minibuffer is displayed:


      ---------- Buffer: Minibuffer ----------
      Enter an expression: (testing)∗
      ---------- Buffer: Minibuffer ----------
    #+end_src


    用户可以立即键入 RET 以使用初始输入作为默认值，或者可以编辑输入。

#+begin_src emacs-lisp
  Function: eval-minibuffer prompt &optional initial ¶
#+end_src

    这个函数使用 minibuffer 读取一个 Lisp 表达式，计算它，然后返回结果。参数 prompt 和 initial 与 read-from-minibuffer 一样使用。

    这个函数只计算调用 read-minibuffer 的结果：
    #+begin_src emacs-lisp
      (eval-minibuffer prompt initial)
      ≡
      (eval (read-minibuffer prompt initial))
    #+end_src

#+begin_src emacs-lisp
  Function: edit-and-eval-command prompt form ¶
#+end_src

    这个函数读取 minibuffer 中的 Lisp 表达式，计算它，然后返回结果。该命令和 eval-minibuffer 的区别在于，这里的初始形式不是可选的，它被视为要转换为打印表示的 Lisp 对象，而不是文本字符串。它使用 prin1 打印，因此如果是字符串，则双引号字符 ('"') 会出现在初始文本中。请参阅输出函数。

    在以下示例中，我们为用户提供了一个初始文本已经是有效形式的表达式：
    #+begin_src emacs-lisp
      (edit-and-eval-command "Please edit: " '(forward-word 1))

      ;; After evaluation of the preceding expression,
      ;;   the following appears in the minibuffer:


      ---------- Buffer: Minibuffer ----------
      Please edit: (forward-word 1)∗
      ---------- Buffer: Minibuffer ----------
    #+end_src
    立即键入 RET 将退出 minibuffer 并评估表达式，从而向前移动一个单词。

** 21.4 小缓冲区历史
minibuffer 历史列表记录以前的 minibuffer 输入，以便用户可以方便地重用它们。它是一个变量，其值是字符串列表（以前的输入），最近的在前。

有许多单独的 minibuffer 历史列表，用于不同类型的输入。为每次使用 minibuffer 指定正确的历史列表是 Lisp 程序员的工作。

您可以使用可选的 history 参数指定一个 minibuffer 历史列表来读取 minibuffer 或完成读取。以下是它的可能值：

#+begin_src emacs-lisp
  variable
#+end_src

    使用变量（符号）作为历史列表。
#+begin_src emacs-lisp
  (variable . startpos)
#+end_src

    使用变量（符号）作为历史列表，并假设初始历史位置为 startpos（非负整数）。

    为 startpos 指定 0 等同于仅指定符号变量。previous-history-element 将显示 minibuffer 中历史列表的最新元素。如果你指定一个正的 startpos，minibuffer 历史函数的行为就好像 (elt variable (1- startpos)) 是当前显示在 minibuffer 中的历史元素。

    为了保持一致性，您还应该使用 minibuffer 输入函数的初始参数将历史元素指定为初始 minibuffer 内容（请参阅初始输入）。

如果您不指定历史，则使用默认历史列表 minibuffer-history。有关其他标准历史列表，请参见下文。您还可以创建自己的历史列表变量；只需在第一次使用之前将其初始化为零。如果变量是本地缓冲区，那么每个缓冲区都有自己的输入历史列表。

read-from-minibuffer 和 complete-read 都会自动将新元素添加到历史列表中，并提供命令以允许用户重用列表中的项目。程序使用历史列表唯一需要做的就是初始化它，并在需要时将其名称传递给输入函数。但是当 minibuffer 输入函数不使用它时，手动修改列表是安全的。

如果列表太长，将新元素添加到历史列表的 Emacs 函数也可以删除旧元素。变量 history-length 指定大多数历史列表的最大长度。要为特定历史列表指定不同的最大长度，请将长度放在历史列表符号的 history-length 属性中。变量 history-delete-duplicates 指定是否删除历史记录中的重复项。

#+begin_src emacs-lisp
  Function: add-to-history history-var newelt &optional maxelt keep-all ¶
#+end_src

    该函数将一个新元素 newelt（如果它不是空字符串）添加到存储在变量 history-var 中的历史列表中，并返回更新后的历史列表。它将列表长度限制为 maxelt（如果非零）或历史长度（如下所述）的值。maxelt 的可能值与 history-length 的值具有相同的含义。history-var 不能引用词法变量。

    通常，如果 history-delete-duplicates 不为零，则 add-to-history 会从历史列表中删除重复的成员。但是，如果 keep-all 不为零，则表示不删除重复项，并且即使 newelt 为空，也要将其添加到列表中。

#+begin_src emacs-lisp
  Variable: history-add-new-input ¶
#+end_src

    如果此变量的值为  ~nil~ ，则从 minibuffer 读取的标准函数不会将新元素添加到历史列表中。这让 Lisp 程序可以使用 add-to-history 显式地管理输入历史。默认值为 t。

#+begin_src emacs-lisp
  User Option: history-length ¶
#+end_src

    此变量的值指定所有未指定其最大长度的历史列表的最大长度。如果值为 t，则表示没有最大值（不要删除旧元素）。如果历史列表变量的交易品种具有非零历史长度属性，它将覆盖该特定历史列表的变量。

#+begin_src emacs-lisp
  User Option: history-delete-duplicates ¶
#+end_src

    如果这个变量的值为 t，这意味着当添加一个新的历史元素时，所有以前的相同元素都被删除。

以下是一些标准的 minibuffer 历史列表变量：

#+begin_src emacs-lisp
  Variable: minibuffer-history ¶
#+end_src

    minibuffer 历史输入的默认历史列表。

#+begin_src emacs-lisp
  Variable: query-replace-history ¶
#+end_src

    查询替换参数的历史列表（以及其他命令的类似参数）。

#+begin_src emacs-lisp
  Variable: file-name-history ¶
#+end_src

    文件名参数的历史列表。

#+begin_src emacs-lisp
  Variable: buffer-name-history ¶
#+end_src

    缓冲区名称参数的历史列表。

#+begin_src emacs-lisp
  Variable: regexp-history ¶
#+end_src

    正则表达式参数的历史列表。

#+begin_src emacs-lisp
  Variable: extended-command-history ¶
#+end_src

    作为扩展命令名称的参数的历史列表。

#+begin_src emacs-lisp
  Variable: shell-command-history ¶
#+end_src

    作为 shell 命令的参数的历史列表。

#+begin_src emacs-lisp
  Variable: read-expression-history ¶
#+end_src

    作为要评估的 Lisp 表达式的参数的历史列表。

#+begin_src emacs-lisp
  Variable: face-name-history ¶
#+end_src

    作为面孔的参数的历史列表。

#+begin_src emacs-lisp
  Variable: custom-variable-history ¶
#+end_src

    由 read-variable 读取的变量名参数的历史列表。

#+begin_src emacs-lisp
  Variable: read-number-history ¶
#+end_src

    由 read-number 读取的数字的历史列表。

#+begin_src emacs-lisp
  Variable: goto-line-history ¶
#+end_src

    goto-line 参数的历史列表。通过自定义用户选项 goto-line-history-local，可以使该变量在每个缓冲区中成为本地变量。

** 21.5 初始输入
用于 minibuffer 输入的几个函数有一个称为 initial 的参数。这是一个主要被弃用的功能，用于指定 minibuffer 应该以某些文本开始，而不是像往常一样为空。

如果 initial 是一个字符串，当用户开始编辑文本时，minibuffer 开始包含字符串的文本，点在末尾。如果用户简单地键入 RET 以退出 minibuffer，它将使用初始输入字符串来确定要返回的值。

我们不鼓励对初始值使用非零值，因为初始输入是一个侵入式接口。历史列表和默认值提供了一种更方便的方法来为用户提供有用的默认输入。

只有一种情况您应该为初始参数指定一个字符串。这是当您为历史参数指定一个 cons 单元格时。请参阅小缓冲区历史记录。

initial 也可以是形式的 cons 单元格（字符串 . 位置）。这意味着在 minibuffer 中插入字符串，但将点放在字符串文本中的位置。

作为一个历史偶然，不同职能部门的立场不一致。在完成读取中，位置的值被解释为原点零；也就是说，值 0 表示字符串的开头，1 表示在第一个字符之后，等等。在 read-minibuffer 和其他支持此参数的非完成 minibuffer 输入函数中，1 表示字符串的开头， 2 表示在第一个字符之后，依此类推。

不推荐使用 cons 单元格作为初始参数的值。

** 21.6 完成
补全是一项功能，它从名称的缩写开始填充名称的其余部分。完成通过将用户的输入与有效名称列表进行比较，并确定有多少名称是由用户键入的内容唯一确定的。例如，当你输入 Cx b (switch-to-buffer)，然后输入你想切换到的缓冲区名称的前几个字母，然后输入 TAB (minibuffer-complete)，Emacs 将名称扩展为尽其所能。

标准 Emacs 命令提供符号、文件、缓冲区和进程名称的补全；使用本节中的函数，您可以实现其他类型名称的补全。

try-completion 函数是完成的基本原语：它返回给定初始字符串的最长确定完成，以及要匹配的给定字符串集。

完成读取功能为完成提供了更高级别的接口。对完成读取的调用指定如何确定有效名称列表。然后该函数使用本地键映射激活迷你缓冲区，该映射将一些键绑定到对完成有用的命令。其他函数提供了方便的简单接口，用于通过完成读取某些类型的名称。


*** 21.6.1 基本完成函数
以下完成函数本身与 minibuffers 无关。我们在这里对其进行描述是为了使它们接近使用 minibuffer 的更高级别的完成功能。

#+begin_src emacs-lisp
  Function: try-completion string collection &optional predicate ¶
#+end_src

    此函数返回集合中所有可能的字符串完成的最长公共子字符串。

    集合称为完成表。它的值必须是字符串列表或 cons 单元格、obarray、哈希表或完成函数。

    try-completion 将 string 与完成表指定的每个允许完成进行比较。如果没有允许的完成匹配，则返回  ~nil~ 。如果只有一个匹配完成，并且匹配是精确的，则返回 t。否则，它返回所有可能匹配完成共有的最长初始序列。

    如果 collection 是一个列表，则允许的补全由列表的元素指定，每个元素都应该是一个字符串，或者一个其 CAR 是字符串或符号的 cons 单元格（使用符号将符号转换为字符串-姓名）。如果列表包含任何其他类型的元素，则这些元素将被忽略。

    如果collection 是一个obarray（参见Creating and Interning Symbols），obarray 中所有符号的名称形成了一组允许的补全。

    如果集合是一个哈希表，那么作为字符串或符号的键是可能的补全。其他键被忽略。

    您还可以将函数用作集合。然后该函数单独负责执行完成；尝试完成返回此函数返回的任何内容。该函数使用三个参数调用：字符串、谓词和  ~nil~ （第三个参数是为了使同一个函数可以在所有完成中使用，并在任何一种情况下都执行适当的操作）。请参阅程序完成。

    如果参数谓词非零，那么它必须是一个参数的函数，除非集合是一个哈希表，在这种情况下它应该是两个参数的函数。它用于测试每个可能的匹配，并且仅当谓词返回非零时才接受匹配。为 predicate 提供的参数是来自 alist 的字符串或 cons 单元格（其 CAR 是字符串），或者来自 obarray 的符号（不是符号名称）。如果 collection 是一个哈希表，则使用两个参数调用谓词，即字符串键和关联值。

    此外，为了被接受，补全还必须匹配completion-regexp-list 中的所有正则表达式。（除非 collection 是一个函数，在这种情况下，该函数必须自己处理 completion-regexp-list。）

    在下面的第一个示例中，字符串 'foo' 与三个 alist CAR 匹配。所有的匹配都以字符 'fooba' 开头，所以这就是结果。在第二个例子中，只有一个可能的匹配，而且是精确的，所以返回值为 t。
    #+begin_src emacs-lisp
      (try-completion
       "foo"
       '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
	   ⇒ "fooba"


      (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
	   ⇒ t
    #+end_src

    在以下示例中，许多符号以字符 ~forw~ 开头，并且所有符号都以单词 ~forward~ 开头。在大多数符号中，这后面都带有一个 ~-~ ，但不是全部，所以最多只能完成 ~前进~ 。

    #+begin_src emacs-lisp
      (try-completion "forw" obarray)
	   ⇒ "forward"
    #+end_src


    最后，在以下示例中，三个可能的匹配项中只有两个通过了谓词测试（字符串 'foobaz' 太短）。两者都以字符串 'foobar' 开头。
    #+begin_src emacs-lisp
      (defun test (s)
	(> (length (car s)) 6))
	   ⇒ test

      (try-completion
       "foo"
       '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
       'test)
	   ⇒ "foobar"
    #+end_src

#+begin_src emacs-lisp
  Function: all-completions string collection &optional predicate ¶
#+end_src

    此函数返回字符串的所有可能完成的列表。此函数的参数与 try-completion 的参数相同，它使用 completion-regexp-list 的方式与 try-completion 相同。

    如果collection是一个函数，它会用三个参数调用：字符串、谓词和t；然后所有完成返回函数返回的任何内容。请参阅程序完成。

    这是一个示例，使用示例中显示的函数 test 进行尝试完成：
    #+begin_src emacs-lisp
      (defun test (s)
	(> (length (car s)) 6))
	   ⇒ test


      (all-completions
       "foo"
       '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
       'test)
	   ⇒ ("foobar1" "foobar2")
    #+end_src

#+begin_src emacs-lisp
  Function: test-completion string collection &optional predicate ¶
#+end_src

    如果 string 是由集合和谓词指定的有效完成替代项，则此函数返回非  ~nil~ 。参数与 try-completion 中的参数相同。例如，如果集合是一个字符串列表，那么如果字符串出现在列表中并且满足谓词，则为真。

    此函数以与 try-completion 相同的方式使用 completion-regexp-list。

    如果谓词是非零并且如果集合包含多个彼此相等的字符串，由比较字符串根据完成忽略大小写确定，那么谓词应该接受全部或不接受。否则，测试完成的返回值本质上是不可预测的。

    如果 collection 是一个函数，则使用三个参数调用它，即字符串、谓词和 lambda 值；无论它返回什么，测试完成都会依次返回。

#+begin_src emacs-lisp
  Function: completion-boundaries string collection predicate suffix ¶
#+end_src

    此函数返回集合将操作的字段的边界，假设字符串保存点之前的文本，后缀保存点之后的文本。

    通常完成对整个字符串进行操作，因此对于所有普通集合，这将始终返回 (0 . (length suffix))。但更复杂的完成，例如文件完成，一次完成一个字段。例如， ~/usr/sh~ 的完成将包括 ~/usr/share/~ 但不包括 ~/usr/share/doc~ ，即使 ~/usr/share/doc~ 存在。此外， ~/usr/sh~ 上的所有完成将不包括 ~/usr/share/~ ，而只包括 ~share/~ 。因此，如果字符串是 ~/usr/sh~ 且后缀是 ~e/doc~ ，完成边界将返回 (5 . 1)，这告诉我们该集合将仅返回与 ~/usr/~ 之后的区域相关的完成信息" 和 "/doc" 之前。尝试完成不受非平凡边界的影响；例如， ~/usr/sh~ 上的尝试完成可能仍会返回 ~/usr/share/~ ，而不是 ~share/~ 。

如果您将完成列表存储在变量中，您应该通过给它一个非零风险局部变量属性来将该变量标记为有风险的。请参阅文件局部变量。

#+begin_src emacs-lisp
  Variable: completion-ignore-case ¶
#+end_src

    如果此变量的值不为  ~nil~ ，则认为 case 在完成中不重要。在 read-file-name 中，此变量被 read-file-name-completion-ignore-case 覆盖（请参阅读取文件名）；在 read-buffer 中，它被 read-buffer-completion-ignore-case 覆盖（请参阅高级完成函数）。

#+begin_src emacs-lisp
  Variable: completion-regexp-list ¶
#+end_src

    这是一个正则表达式列表。补全函数仅在匹配此列表中的所有正则表达式时才考虑可接受的补全，并且 case-fold-search（请参阅搜索和案例）绑定到 completion-ignore-case 的值。

#+begin_src emacs-lisp
  Macro: lazy-completion-table var fun ¶
#+end_src

    此宏提供了一种将变量 var 初始化为以惰性方式完成的集合的方法，在第一次需要它们之前不计算其实际内容。您可以使用此宏生成一个值，并将其存储在 var 中。正确值的实际计算是在您第一次使用 var 完成时完成的。这是通过不带参数调用 fun 来完成的。fun 返回的值成为 var 的永久值。

    这是一个例子：
    #+begin_src emacs-lisp
      (defvar foo (lazy-completion-table foo make-my-alist))
    #+end_src
有几个函数采用现有的完成表并返回修改后的版本。完成表大小写折叠返回一个不区分大小写的表。completion-table-in-turn 和 completion-table-merge 以不同的方式组合多个输入表。完成表颠覆改变表以使用不同的初始前缀。completion-table-with-quoting 返回一个适合对引用文本进行操作的表。completion-table-with-predicate 过滤带有谓词函数的表。completion-table-with-terminator 添加一个终止字符串。

*** 21.6.2 完成和小缓冲区
本节描述了从 minibuffer 中读取并完成的基本接口。

#+begin_src emacs-lisp
  Function: completing-read prompt collection &optional predicate require-match initial history default inherit-input-method ¶
#+end_src

    此函数读取 minibuffer 中的字符串，通过提供完成来帮助用户。它使用提示符激活 minibuffer，提示符必须是一个字符串。

    实际完成是通过将完成表集合和完成谓词谓词传递给函数 try-completion 来完成的（请参阅基本完成函数）。这发生在用于完成的本地键盘映射中绑定的某些命令中。其中一些命令也称为测试完成。因此，如果谓词非零，它应该与集合和完成忽略情况兼容。请参阅测试完成的定义。

    有关收集是函数时的详细要求，请参阅程序化完成。

    可选参数 require-match 的值决定了用户如何退出 minibuffer：

	 如果为  ~nil~ ，则无论 minibuffer 中的输入如何，通常的 minibuffer exit 命令都会起作用。
	 如果 t，通常的 minibuffer 退出命令将不会退出，除非输入完成到集合元素。
	 如果确认，用户可以使用任何输入退出，但如果输入不是集合元素，则要求确认。
	 如果confirm-after-completion，用户可以使用任何输入退出，但如果前面的命令是完成命令（即minibuffer-confirm-exit-commands中的命令之一）并且结果输入不是，则要求确认收藏的一个元素。请参阅完成完成的 Minibuffer 命令。
	 require-match 的任何其他值的行为都类似于 t，除了 exit 命令在执行完成时不会退出。

    但是，无论 require-match 的值如何，始终允许空输入；在这种情况下，如果它是一个列表，则完成读取返回默认的第一个元素；""，如果默认为  ~nil~ ；或默认。用户也可以通过历史命令使用默认的一个或多个字符串。

    如果 require-match 为  ~nil~ ，则函数 completed-read 使用 minibuffer-local-completion-map 作为键映射，如果 require-match 为非  ~nil~ ，则使用 minibuffer-local-must-match-map。请参阅完成完成的 Minibuffer 命令。

    参数 history 指定用于保存输入和 minibuffer 历史命令的历史列表变量。它默认为 minibuffer-history。如果历史是符号 t，则不记录历史。请参阅小缓冲区历史记录。

    参数 initial 大多已被弃用；我们建议仅在为历史指定 cons 单元格的同时使用非  ~nil~  值。请参阅初始输入。对于默认输入，请改用默认值。

    如果参数inherit-input-method 不为 ~nil~ ，那么minibuffer 会继承当前输入法（参见Input Methods）和enable-multibyte-characters 的设置（参见Text Representations）从进入minibuffer 之前的当前缓冲区。

    如果变量completion-ignore-case 不为 ~nil~ ，则在将输入与可能的匹配项进行比较时，完成会忽略大小写。请参阅基本完成功能。在这种操作模式下，谓词也必须忽略大小写，否则你会得到令人惊讶的结果。

    以下是使用完成读取的示例：

    #+begin_src emacs-lisp


      (completing-read
       "Complete a foo: "
       '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
       nil t "fo")


      ;; After evaluation of the preceding expression,
      ;;   the following appears in the minibuffer:

      ---------- Buffer: Minibuffer ----------
      Complete a foo: fo∗
      ---------- Buffer: Minibuffer ----------
    #+end_src

    如果用户随后键入 DEL DEL b RET，则完成读取返回 barfoo。

    完成读取函数绑定变量以将信息传递给实际完成的命令。它们在下一节中描述。

#+begin_src emacs-lisp
  Variable: completing-read-function ¶
#+end_src

    这个变量的值必须是一个函数，通过完成读取调用它来实际完成它的工作。它应该接受与完成读取相同的参数。这可以绑定到不同的函数以完全覆盖完成读取的正常行为。

*** 21.6.3 完成完成的 Minibuffer 命令
本节描述了在 minibuffer 中用于完成的键盘映射、命令和用户选项。

#+begin_src emacs-lisp
  Variable: minibuffer-completion-table ¶
#+end_src

    此变量的值是用于在 minibuffer 中完成的完成表（参见基本完成函数）。这是包含完成读取传递给尝试完成的缓冲区局部变量。它由 minibuffer 完成命令使用，例如 minibuffer-complete。

#+begin_src emacs-lisp
  Variable: minibuffer-completion-predicate ¶
#+end_src

    该变量的值是完成读取传递给尝试完成的谓词。该变量也被其他 minibuffer 完成函数使用。

#+begin_src emacs-lisp
  Variable: minibuffer-completion-confirm ¶
#+end_src

    这个变量决定了 Emacs 在退出 minibuffer 之前是否要求确认；complete-read 设置此变量，函数 minibuffer-complete-and-exit 在退出前检查该值。如果值为  ~nil~ ，则不需要确认。如果值为confirm，用户可能会退出一个不是有效的完成替代的输入，但Emacs 要求确认。如果值为confirm-after-completion，则用户可能会以不是有效的完成替代的输入退出，但如果用户在minibuffer-confirm-exit-中的任何完成命令之后立即提交输入，Emacs 会要求确认命令。

#+begin_src emacs-lisp
  Variable: minibuffer-confirm-exit-commands ¶
#+end_src

    如果完成读取的要求匹配参数是完成后确认，则此变量包含导致 Emacs 在退出迷你缓冲区之前要求确认的命令列表。如果用户在调用此列表中的任何命令后立即尝试退出 minibuffer，则请求确认。

#+begin_src emacs-lisp
  Command: minibuffer-complete-word ¶
#+end_src

    这个函数最多用一个单词来完成 minibuffer 的内容。即使 minibuffer 内容只有一个补全， minibuffer-complete-word 也不会在第一个不是单词组成的字符之外添加任何字符。请参阅语法表。

#+begin_src emacs-lisp
  Command: minibuffer-complete ¶
#+end_src

    这个函数尽可能地完成了 minibuffer 的内容。

#+begin_src emacs-lisp
  Command: minibuffer-complete-and-exit ¶
#+end_src

    这个函数完成了 minibuffer 的内容，如果不需要确认，即如果 minibuffer-completion-confirm 为  ~nil~ ，则退出。如果需要确认，则通过立即重复此命令来给出 - 该命令被编程为连续运行两次时无需确认即可工作。

#+begin_src emacs-lisp
  Command: minibuffer-completion-help ¶
#+end_src

    此函数创建当前 minibuffer 内容的可能完成列表。它通过使用变量 minibuffer-completion-table 的值作为集合参数和 minibuffer-completion-predicate 的值作为谓词参数来调用所有完成。完成列表在名为 *Completions* 的缓冲区中显示为文本。

#+begin_src emacs-lisp
  Function: display-completion-list completions ¶
#+end_src

    此函数在标准输出中显示流的完成，通常是缓冲区。（有关流的更多信息，请参阅阅读和打印 Lisp 对象。）参数完成通常是由所有完成返回的完成列表，但并非必须如此。每个元素可以是一个符号或一个字符串，其中任何一个都可以简单地打印出来。它也可以是两个字符串的列表，就像字符串被连接一样打印。两个字符串中的第一个是实际完成，第二个字符串用作注释。

    该函数由 minibuffer-completion-help 调用。使用它的一种常见方法是与 with-output-to-temp-buffer 一起使用，如下所示：
    #+begin_src emacs-lisp
      (with-output-to-temp-buffer "*Completions*"
	(display-completion-list
	  (all-completions (buffer-string) my-alist)))
    #+end_src

#+begin_src emacs-lisp
  User Option: completion-auto-help ¶
#+end_src

    如果此变量不为  ~nil~ ，则完成命令会自动显示可能的完成列表，因为下一个字符不是唯一确定的，因此无法完成任何内容。

#+begin_src emacs-lisp
  Variable: minibuffer-local-completion-map ¶
#+end_src

    当不需要完全匹配其中一个完成时，完成读取使用此值作为本地键映射。默认情况下，此键映射进行以下绑定：

#+begin_src emacs-lisp
  ?
#+end_src

	 迷你缓冲区完成帮助
#+begin_src emacs-lisp
  SPC
#+end_src

	 minibuffer-complete-word
#+begin_src emacs-lisp
  TAB
#+end_src

	 小缓冲区完成

    并使用 minibuffer-local-map 作为其父键映射（参见 minibuffer-local-map 的定义）。

#+begin_src emacs-lisp
  Variable: minibuffer-local-must-match-map ¶
#+end_src

    当需要完全匹配其中一个完成时，完成读取使用此值作为本地键映射。因此，没有键绑定到 exit-minibuffer，即无条件退出 minibuffer 的命令。默认情况下，此键映射进行以下绑定：

#+begin_src emacs-lisp
  C-j
#+end_src

	 minibuffer-完成并退出
#+begin_src emacs-lisp
  RET
#+end_src

	 minibuffer-完成并退出

    并使用 minibuffer-local-completion-map 作为其父键映射。

#+begin_src emacs-lisp
  Variable: minibuffer-local-filename-completion-map ¶
#+end_src

    这是一个简单地解除绑定 SPC 的稀疏键映射；因为文件名可以包含空格。函数 read-file-name 将此键映射与 minibuffer-local-completion-map 或 minibuffer-local-must-match-map 组合。

#+begin_src emacs-lisp
  Variable: minibuffer-beginning-of-buffer-movement ¶
#+end_src

    如果非零，如果 point 位于提示符末尾，则 M-< 命令将移动到提示符末尾。如果 point 在提示结束处或之前，则移动到缓冲区的开头。如果此变量为  ~nil~ ，则该命令的行为类似于缓冲区的开头。

*** 21.6.4 高级完成函数
本节描述用于读取某些类型名称的高级便利函数。

在大多数情况下，您不应该在 Lisp 函数的中间调用这些函数。如果可能，在交互式规范中，将所有 minibuffer 输入作为读取命令参数的一部分。请参阅定义命令。

#+begin_src emacs-lisp
  Function: read-buffer prompt &optional default require-match predicate ¶
#+end_src

    此函数读取缓冲区的名称并将其作为字符串返回。它以提示的方式提示。参数 default 是要使用的默认名称，如果用户以空的 minibuffer 退出时返回的值。如果非零，它应该是一个字符串、一个字符串列表或一个缓冲区。如果是列表，则默认值为该列表的第一个元素。它在提示中被提及，但没有作为初始输入插入到 minibuffer 中。

    参数提示应该是一个以冒号和空格结尾的字符串。如果 default 不是  ~nil~ ，该函数将它插入到冒号之前的提示符中，以遵循从 minibuffer 中读取默认值的约定（请参阅 Emacs 编程技巧）。

    可选参数 require-match 与完成读取具有相同的含义。请参阅完成和 Minibuffer。

    可选参数谓词，如果非  ~nil~ ，则指定一个函数来过滤应考虑的缓冲区：该函数将以每个潜在候选者作为其参数调用，并应返回  ~nil~  拒绝候选者，非  ~nil~  接受它.

    在以下示例中，用户输入 ~minibuffer.t~ ，然后键入 RET。参数 require-match 是 t，唯一以给定输入开头的缓冲区名称是 ~minibuffer.texi~ ，因此该名称就是值。
    #+begin_src emacs-lisp
      (read-buffer "Buffer name: " "foo" t)

      ;; After evaluation of the preceding expression,
      ;;   the following prompt appears,
      ;;   with an empty minibuffer:


      ---------- Buffer: Minibuffer ----------
      Buffer name (default foo): ∗
      ---------- Buffer: Minibuffer ----------


      ;; The user types minibuffer.t RET.
	   ⇒ "minibuffer.texi"
    #+end_src


#+begin_src emacs-lisp
  User Option: read-buffer-function ¶
#+end_src

    这个变量，如果非零，指定一个读取缓冲区名称的函数。read-buffer 调用此函数而不是执行其通常的工作，并将相同的参数传递给 read-buffer。

#+begin_src emacs-lisp
  User Option: read-buffer-completion-ignore-case ¶
#+end_src

    如果此变量为非零，则读取缓冲区在读取缓冲区名称时执行完成时会忽略大小写。

#+begin_src emacs-lisp
  Function: read-command prompt &optional default ¶
#+end_src

    此函数读取命令的名称并将其作为 Lisp 符号返回。参数提示在 read-from-minibuffer 中使用。回想一下，命令是 commandp 返回 t 的任何东西，命令名称是 commandp 返回 t 的符号。请参阅交互式呼叫。

    参数 default 指定用户输入空输入时返回的内容。它可以是符号、字符串或字符串列表。如果它是一个字符串，read-command 会在返回它之前对其进行实习。如果它是一个列表，则 read-command 会实习该列表的第一个元素。如果 default 为  ~nil~ ，则表示没有指定默认值；那么如果用户输入 null 输入，则返回值为 (intern "")，即名称为空字符串的符号，其打印表示为 ##（参见符号类型）。
    #+begin_src emacs-lisp


      (read-command "Command name? ")

      ;; After evaluation of the preceding expression,
      ;;   the following prompt appears with an empty minibuffer:


      ---------- Buffer: Minibuffer ----------
      Command name?
      ---------- Buffer: Minibuffer ----------
    #+end_src

    如果用户键入 forward-c RET，则此函数返回 forward-char。

    读取命令函数是完成读取的简化接口。它使用变量 obarray 以便在现存的 Lisp 符号集中完成，它使用 commandp 谓词以便只接受命令名称：

    #+begin_src emacs-lisp
      (read-command prompt)
      ≡
      (intern (completing-read prompt obarray
			       'commandp t nil))
    #+end_src


#+begin_src emacs-lisp
  Function: read-variable prompt &optional default ¶
#+end_src

    此函数读取可自定义变量的名称并将其作为符号返回。它的参数与 read-command 的参数形式相同。它的行为与 read-command 类似，只是它使用谓词 custom-variable-p 而不是 commandp。

#+begin_src emacs-lisp
  Command: read-color &optional prompt convert allow-empty display ¶
#+end_src

    此函数读取作为颜色规范的字符串，可以是颜色名称或 RGB 十六进制值，例如 #RRRGGGBBB。它提示提示符（默认值： ~颜色（名称或#RGB 三元组）：~ ）并为颜色名称提供补全，但不为十六进制 RGB 值提供补全。除了标准颜色的名称，完成候选包括点的前景色和背景色。

    颜色名称中描述了有效的 RGB 值。

    该函数的返回值是用户在 minibuffer 中键入的字符串。但是，当以交互方式调用或可选参数 convert 为非  ~nil~  时，它会将任何输入颜色名称转换为相应的 RGB 值字符串并返回。此功能需要输入有效的颜色规范。当 allow-empty 为非  ~nil~  并且用户输入 null 输入时，允许使用空颜色名称。

    交互方式，或者当 display 为非  ~nil~  时，返回值也会显示在 echo 区域中。

另请参见用户选择的编码系统中的函数 read-coding-system 和 read-non- ~nil~ -coding-system 以及输入法中的 read-input-method-name。

*** 21.6.5 读取文件名
高级完成函数 read-file-name、read-directory-name 和 read-shell-command 旨在分别读取文件名、目录名和 shell 命令。它们提供特殊功能，包括自动插入默认目录。

#+begin_src emacs-lisp
  Function: read-file-name prompt &optional directory default require-match initial predicate ¶
#+end_src

    此函数读取文件名，提示并提供完成。

    作为一个例外，如果满足以下所有条件，则此函数使用图形文件对话框而不是 minibuffer 读取文件名：

	 它是通过鼠标命令调用的。
	 所选框架位于支持此类对话框的图形显示上。
	 变量 use-dialog-box 不为零。请参阅 GNU Emacs 手册中的对话框。
	 下面描述的目录参数没有指定远程文件。请参阅 GNU Emacs 手册中的远程文件。

    使用图形文件对话框时的确切行为取决于平台。在这里，我们简单地记录使用 minibuffer 时的行为。

    read-file-name 不会自动扩展返回的文件名。如果需要绝对文件名，您可以自己调用 expand-file-name。

    可选参数 require-match 与完成读取具有相同的含义。请参阅完成和 Minibuffer。

    参数目录指定用于完成相对文件名的目录。它应该是一个绝对目录名。如果变量 insert-default-directory 不为  ~nil~ ，则目录也作为初始输入插入到 minibuffer 中。它默认为当前缓冲区的 default-directory 值。

    如果您指定 initial，则这是要插入缓冲区的初始文件名（在目录之后，如果已插入）。在这种情况下，点位于初始的开头。initial 的默认值为  ~nil~ ——不插入任何文件名。要查看 initial 的作用，请在访问文件的缓冲区中尝试命令 Cx Cv。请注意：我们建议在大多数情况下使用默认值而不是初始值。

    如果 default 为非  ~nil~ ，则如果用户以与最初插入的 read-file-name 相同的非空内容退出 minibuffer，则该函数返回 default。如果 insert-default-directory 为非零，则初始 minibuffer 内容始终为非空，默认情况下是这样。无论 require-match 的值如何，都不检查 default 的有效性。但是，如果 require-match 不为零，则初始 minibuffer 内容应该是有效的文件（或目录）名称。否则，如果用户在没有任何编辑的情况下退出，read-file-name 将尝试完成，并且不返回默认值。默认值也可通过历史命令获得。

    如果 default 是  ~nil~ ，read-file-name 会尝试找到一个替代的默认值来代替它，它的处理方式与明确指定的方式完全相同。如果 default 为  ~nil~ ，但 initial 为非  ~nil~ ，则默认为从 directory 和 initial 中获取的绝对文件名。如果 default 和 initial 都为  ~nil~  并且缓冲区正在访问文件，则 read-file-name 使用该文件的绝对文件名作为默认值。如果缓冲区没有访问文件，则没有默认值。在这种情况下，如果用户在没有任何编辑的情况下键入 RET，read-file-name 只会返回 minibuffer 的预插入内容。

    如果用户在一个空的 minibuffer 中输入 RET，这个函数返回一个空字符串，不管 require-match 的值是多少。例如，用户如何使用 Mx set-visited-file-name 使当前缓冲区不访问文件。

    如果谓词非零，它指定一个参数的函数，该函数决定哪些文件名是可接受的完成替代。如果谓词为其返回非零，则文件名是可接受的值。

    以下是使用读取文件名的示例：
    #+begin_src emacs-lisp
      (read-file-name "The file is ")

      ;; After evaluation of the preceding expression,
      ;;   the following appears in the minibuffer:


      ---------- Buffer: Minibuffer ----------
      The file is /gp/gnu/elisp/∗
      ---------- Buffer: Minibuffer ----------
    #+end_src
    键入手动 TAB 会导致以下结果：
    #+begin_src emacs-lisp
      ---------- Buffer: Minibuffer ----------
      The file is /gp/gnu/elisp/manual.texi∗
      ---------- Buffer: Minibuffer ----------
    #+end_src

    如果用户键入 RET，read-file-name 以字符串 ~/gp/gnu/elisp/manual.texi~ 的形式返回文件名。

#+begin_src emacs-lisp
  Variable: read-file-name-function ¶
#+end_src

    如果非零，这应该是一个接受与读取文件名相同的参数的函数。当调用 read-file-name 时，它​​使用提供的参数调用此函数，而不是执行其通常的工作。

#+begin_src emacs-lisp
  User Option: read-file-name-completion-ignore-case ¶
#+end_src

    如果此变量不为  ~nil~ ，则 read-file-name 在执行完成时会忽略大小写。

#+begin_src emacs-lisp
  Function: read-directory-name prompt &optional directory default require-match initial ¶
#+end_src

    此函数类似于 read-file-name 但仅允许目录名称作为完成替代。

    如果 default 为  ~nil~  且 initial 为非  ~nil~ ，则 read-directory-name 通过组合 directory（或当前缓冲区的默认目录，如果 directory 为  ~nil~ ）和 initial 来构造替代默认值。如果 default 和 initial 都为  ~nil~ ，则此函数使用目录作为替代默认值，如果 directory 为  ~nil~ ，则使用当前缓冲区的默认目录。

#+begin_src emacs-lisp
  User Option: insert-default-directory ¶
#+end_src

    这个变量被 read-file-name 使用，因此，间接地被大多数读取文件名的命令使用。（这包括所有在交互形式中使用代码字母 'f' 或 'F' 的命令。请参阅交互代码字符。）它的值控制 read-file-name 是否通过将默认目录的名称放在 minibuffer 中开始，加上初始文件名（如果有）。如果此变量的值为  ~nil~ ，则 read-file-name 不会在 minibuffer 中放置任何初始输入（除非您使用初始参数指定初始输入）。在这种情况下，默认目录仍用于完成相对文件名，但不显示。

    如果此变量为  ~nil~  并且初始 minibuffer 内容为空，则用户可能必须显式获取下一个历史元素以访问默认值。如果变量不为  ~nil~ ，则初始 minibuffer 内容总是非空的，用户总是可以通过立即在未编辑的 minibuffer 中键入 RET 来请求默认值。（往上看。）

    例如：
    #+begin_src emacs-lisp


      ;; Here the minibuffer starts out with the default directory.
      (let ((insert-default-directory t))
	(read-file-name "The file is "))


      ---------- Buffer: Minibuffer ----------
      The file is ~lewis/manual/∗
      ---------- Buffer: Minibuffer ----------


      ;; Here the minibuffer is empty and only the prompt
      ;;   appears on its line.
      (let ((insert-default-directory nil))
	(read-file-name "The file is "))


      ---------- Buffer: Minibuffer ----------
      The file is ∗
      ---------- Buffer: Minibuffer ----------
    #+end_src
#+begin_src emacs-lisp
  Function: read-shell-command prompt &optional initial history &rest args ¶
#+end_src

    该函数从 minibuffer 中读取一个 shell 命令，以提示符提示并提供智能完成。它使用适合命令名称的候选词来完成命令的第一个单词，其余的命令单词作为文件名。

    此函数使用 minibuffer-local-shell-command-map 作为 minibuffer 输入的键映射。history 参数指定要使用的历史列表；如果省略或为零，则默认为 shell-command-history（请参阅 shell-command-history）。可选参数 initial 指定 minibuffer 的初始内容（参见初始输入）。其余的 args（如果存在）用作 read-from-minibuffer 中的默认参数和继承输入方法参数（请参阅Reading Text Strings with the Minibuffer）。

#+begin_src emacs-lisp
  Variable: minibuffer-local-shell-command-map ¶
#+end_src

    此键映射由 read-shell-command 用于完成作为 shell 命令一部分的命令和文件名。它使用 minibuffer-local-map 作为其父键映射，并将 TAB 绑定到完成点。

*** 21.6.6 完成变量
以下是一些可用于更改默认完成行为的变量。

#+begin_src emacs-lisp
  User Option: completion-styles ¶
#+end_src

    此变量的值是用于执行完成的完成样式（符号）列表。完成样式是一组用于生成完成的规则​​。出现此列表的每个符号都必须在完成样式列表中具有相应的条目。

#+begin_src emacs-lisp
  Variable: completion-styles-alist ¶
#+end_src

    此变量存储可用完成样式的列表。列表中的每个元素都有以下形式

    #+begin_src emacs-lisp
      (style try-completion all-completions doc)
    #+end_src

    这里的style是完成样式的名称（一个符号），可以在completion-styles变量中用来指代这个样式；try-completion 是完成完成的函数；all-completions 是列出完成的函数；doc 是描述完成样式的字符串。

    try-completion 和 all-completion 函数都应该接受四个参数：字符串、集合、谓词和点。字符串、集合和谓词参数与 try-completion 中的含义相同（请参阅基本完成函数），并且 point 参数是字符串中 point 的位置。如果每个函数执行了它的工作，它应该返回一个非  ~nil~  值，如果它没有完成它应该返回一个  ~nil~ （例如，如果没有办法根据完成样式完成字符串）。

    当用户调用像 minibuffer-complete 之类的完成命令时（参见 Minibuffer Commands that Do Completion），Emacs 会查找 completion-styles 中列出的第一个样式并调用它的 try-completion 函数。如果这个函数返回  ~nil~ ，Emacs 将移动到下一个列出的完成样式并调用它的 try-completion 函数，依此类推，直到其中一个 try-completion 函数成功执行完成并返回一个非  ~nil~  值。类似的过程用于通过 all-completions 函数列出完成。

    有关可用完成样式的描述，请参阅 The GNU Emacs Manual 中的 Completion Styles。

#+begin_src emacs-lisp
  User Option: completion-category-overrides ¶
#+end_src

    此变量指定在完成某些类型的文本时要使用的特殊完成样式和其他完成行为。它的值应该是一个具有表单元素的列表 (category . alist)。类别是描述正在完成的事情的符号；目前，定义了缓冲区、文件和 unicode-name 类别，但其他类别可以通过专门的完成函数定义（参见 Programmed Completion）。alist 是一个关联列表，描述了相应类别的完成应如何表现。支持以下 alist 键：

#+begin_src emacs-lisp
  styles
#+end_src

	 该值应该是完成样式（符号）的列表。
#+begin_src emacs-lisp
  cycle
#+end_src

	 该值应该是该类别的completion-cycle-threshold 的值（请参阅The GNU Emacs Manual 中的Completion Options）。

    将来可能会定义其他 alist 条目。

#+begin_src emacs-lisp
  Variable: completion-extra-properties ¶
#+end_src

    此变量用于指定当前完成命令的额外属性。它旨在通过专门的完成命令进行绑定。它的值应该是属性和值对的列表。支持以下属性：

#+begin_src emacs-lisp
  :annotation-function
#+end_src

	 该值应该是在完成缓冲区中添加注释的函数。这个函数必须接受一个参数，一个完成，并且应该返回  ~nil~  或一个要在完成旁边显示的字符串。除非此函数将自己的面放在注释后缀字符串上，否则默认情况下会将完成注释面添加到该字符串中。
#+begin_src emacs-lisp
  :affixation-function
#+end_src

	 该值应该是为完成添加前缀和后缀的函数。这个函数必须接受一个参数，一个完成列表，并且应该返回一个带注释的完成列表。返回列表的每个元素必须是三元素列表、完成、前缀字符串和后缀字符串。此函数优先于 :annotation-function。
#+begin_src emacs-lisp
  :exit-function
#+end_src

	 该值应该是执行完成后要运行的函数。该函数应该接受两个参数，字符串和状态，其中字符串是字段完成的文本，状态指示发生了什么样的操作：如果文本现在完成，则完成，如果文本无法进一步完成但完成是唯一的未完成，或者如果文本是有效的完成，但可以进一步完成。

*** 21.6.7 编程完成
有时，提前创建包含所有预期可能完成的 alist 或 obarray 是不可能或不方便的。在这种情况下，您可以提供自己的函数来计算给定字符串的完成。这称为程序完成。Emacs 在完成文件名时使用程序完成（参见文件名完成），以及许多其他情况。

要使用此功能，请将函数作为集合参数传递给完成读取。complete-read 函数安排将您的完成函数传递给 try-completion、all-completions 和其他基本完成函数，然后让您的函数完成所有工作。

完成函数应该接受三个参数：

    要完成的字符串。
    一个谓词函数，用于过滤可能的匹配项，如果没有，则为  ~nil~ 。该函数应该为每个可能的匹配调用谓词，如果谓词返回  ~nil~ ，则忽略匹配。
    指定要执行的完成操作类型的标志；有关这些操作的详细信息，请参阅基本完成功能。此标志可能是以下值之一。

#+begin_src emacs-lisp
  nil
#+end_src

	 这指定了一个尝试完成操作。如果没有匹配项，该函数应返回  ~nil~ ；如果指定的字符串是唯一且完全匹配的，它应该返回 t；否则它应该返回所有匹配项中最长的公共前缀子字符串。
#+begin_src emacs-lisp
  t
#+end_src

	 这指定了一个全部完成操作。该函数应返回指定字符串的所有可能完成的列表。
#+begin_src emacs-lisp
  lambda
#+end_src

	 这指定了一个测试完成操作。如果指定的字符串与某个完成选项完全匹配，则该函数应返回 t；否则为零。
#+begin_src emacs-lisp
  (boundaries . suffix)
#+end_src

	 这指定了完成边界操作。该函数应返回 (boundaries start . end)，其中 start 是指定字符串中开始边界的位置，end 是后缀中结束边界的位置。

	 如果 Lisp 程序返回非平凡边界，它应该确保所有完成操作与它们一致。all-completion 返回的完成应该只与完成边界覆盖的前缀和后缀有关。有关完成边界的精确预期语义，请参见基本完成函数。
#+begin_src emacs-lisp
  metadata
#+end_src

	 这指定了对有关当前完成状态的信息的请求。返回值应采用 (metadata .alist) 形式，其中 alist 是一个 alist，其元素如下所述。

    如果标志有任何其他值，完成函数应该返回  ~nil~ 。

以下是完成函数响应元数据标志参数可能返回的元数据条目列表：

#+begin_src emacs-lisp
  category
#+end_src

    该值应该是描述完成函数试图完成的文本类型的符号。如果符号匹配completion-category-overrides 中的键之一，则覆盖通常的完成行为。请参阅完成变量。
#+begin_src emacs-lisp
  annotation-function
#+end_src

    该值应该是用于注释完成的函数。该函数应该接受一个参数，字符串，这是一个可能的完成。它应该返回一个字符串，该字符串显示在 *Completions* 缓冲区中的完成字符串之后。除非此函数将自己的面放在注释后缀字符串上，否则默认情况下会将完成注释面添加到该字符串中。
#+begin_src emacs-lisp
  affixation-function
#+end_src

    该值应该是为完成添加前缀和后缀的函数。该函数应该有一个参数，completions，它是一个可能的完成列表。它应该返回这样一个完成列表，其中每个元素都包含三个元素的列表：一个完成，在 *Completions* 缓冲区中显示在完成字符串之前的前缀，以及在完成字符串之后显示的后缀。此功能优先于注释功能。
#+begin_src emacs-lisp
  group-function
#+end_src

    该值应该是用于对完成候选进行分组的函数。该函数必须接受两个参数，completion，它是一个完成候选和 transform，它是一个布尔标志。如果 transform 为  ~nil~ ，该函数必须返回候选人所属组的组标题。返回的标题也可以为  ~nil~ 。否则，该函数必须返回转换后的候选者。例如，转换可以删除显示在组标题中的冗余前缀。
#+begin_src emacs-lisp
  display-sort-function
#+end_src

    该值应该是用于对完成进行排序的函数。该函数应该接受一个参数，完成字符串列表，并返回完成字符串的排序列表。允许破坏性地改变输入列表。
#+begin_src emacs-lisp
  cycle-sort-function
#+end_src

    该值应该是用于对完成进行排序的函数，当完成循环阈值不为零并且用户正在循环完成选项时。请参阅 GNU Emacs 手册中的完成选项。它的参数列表和返回值与 display-sort-function 相同。

#+begin_src emacs-lisp
  Function: completion-table-dynamic function &optional switch-buffer ¶
#+end_src

    此函数是编写可充当编程完成函数的函数的便捷方式。参数函数应该是一个函数，它接受一个参数，一个字符串，并返回一个包含所有可能完成的完成表（参见基本完成函数）。函数返回的表还可以包含与字符串参数不匹配的元素；它们会被完成表动态自动过滤掉。特别是，函数可以忽略其参数并返回所有可能完成的完整列表。您可以将完成表动态视为函数和编程完成函数的接口之间的转换器。

    如果可选参数 switch-buffer 不为零，并且在 minibuffer 中执行完成，则将调用函数并将当前缓冲区设置为进入 minibuffer 的缓冲区。

    completion-table-dynamic 的返回值是一个函数，可以用作 try-completion 和 all-completion 的第二个参数。请注意，此函数将始终返回空元数据和微不足道的边界。

#+begin_src emacs-lisp
  Function: completion-table-with-cache function &optional ignore-case ¶
#+end_src

    这是完成表动态的包装器，它保存最后一个参数结果对。这意味着具有相同参数的多个查找只需要调用一次函数。当涉及缓慢的操作时，这可能很有用，例如调用外部进程。

*** 21.6.8 在普通缓冲区中完成
虽然完成通常在 minibuffer 中完成，但完成功能也可以用于普通 Emacs 缓冲区中的文本。在许多主要模式中，缓冲区内完成由 CMi 或 M-TAB 命令执行，绑定到完成点。请参阅 GNU Emacs 手册中的符号完成。该命令使用异常钩子变量completion-at-point-functions：

#+begin_src emacs-lisp
  Variable: completion-at-point-functions ¶
#+end_src

    这个异常钩子的值应该是一个函数列表，用于计算完成表（参见基本完成函数）以完成该点的文本。主要模式可以使用它来提供特定于模式的完成表（请参阅主要模式约定）。

    当completion-at-point命令运行时，它会一一调用列表中的函数，不带任何参数。每个函数都应该返回  ~nil~  ，除非它可以并且想要对当前文本的完成数据负责。否则，它应该返回以下形式的列表：

    #+begin_src emacs-lisp
      (start end collection . props)
    #+end_src

    start 和 end 分隔要完成的文本（应该包含点）。collection 是用于完成该文本的完成表，其形式适合作为第二个参数传递给 try-completion（请参阅基本完成函数）；通过完成样式中定义的完成样式（请参阅完成变量），将以通常的方式从此完成表生成完成替代项。props 是附加信息的属性列表；识别完成额外属性中的任何属性（请参阅完成变量），以及以下附加属性：

    ：谓词

	 该值应该是完成候选者需要满足的谓词。
    ：独家的

	 如果值为 no，则如果完成表未能与点处的文本匹配，则完成点移动到完成点函数中的下一个函数，而不是报告完成失败。

    这个钩子上的函数通常应该快速返回，因为它们可能会被非常频繁地调用（例如，从 post-command-hook）。如果生成完成列表是一项昂贵的操作，强烈建议提供收集功能。Emacs 可能会在内部多次调用完成点函数中的函数，但只关心其中一些调用的集合值。通过提供收集功能，Emacs 可以推迟生成完成，直到需要。您可以使用 completion-table-dynamic 创建一个包装函数：

    #+begin_src emacs-lisp
      ;; Avoid this pattern.
      (let ((beg ...) (end ...) (my-completions (my-make-completions)))
	(list beg end my-completions))

      ;; Use this instead.
      (let ((beg ...) (end ...))
	(list beg
	      end
	      (completion-table-dynamic
		(lambda (_)
		  (my-make-completions)))))
    #+end_src

    此外，集合通常不应根据开始和结束之间的当前文本进行预过滤，因为这是完成点函数的调用者根据它决定使用的完成样式来执行此操作的责任。

    完成点函数中的函数也可以返回一个函数而不是如上所述的列表。在这种情况下，调用返回的函数，没有参数，它完全负责执行完成。我们不鼓励这种用法；它仅旨在帮助将旧代码转换为使用完成点。

    完成点函数中第一个返回非零值的函数由点完成函数使用。不调用其余函数。例外情况是存在 :exclusive 规范，如上所述。

以下函数提供了一种方便的方法来对 Emacs 缓冲区中的任意一段文本执行补全：

#+begin_src emacs-lisp
  Function: completion-in-region start end collection &optional predicate ¶
#+end_src

    此函数使用集合完成当前缓冲区中起始和结束位置之间的文本。参数集合与 try-completion 中的含义相同（请参阅基本完成函数）。

    此函数将完成文本直接插入当前缓冲区。与完成读取不同（请参阅完成和迷你缓冲区），它不会激活迷你缓冲区。

    要使此功能起作用，点必须位于开始和结束之间的某个位置。

** 21.7 是或否查询
本节介绍用于向用户询问是或否问题的功能。函数 y-or-np 可以用单个字符来回答；对于无意的错误答案不会造成严重后果的问题，它很有用。yes-or-no-p 适用于更重要的问题，因为它需要三个或四个字符来回答。

如果在使用鼠标调用的命令中调用了这些函数中的任何一个——更准确地说，如果 last-nonmenu-event（请参阅命令循环中的信息）为  ~nil~  或列表——则它使用对话框或 pop-向上菜单询问问题。否则，它使用键盘输入。您可以通过将 last-nonmenu-event 绑定到调用周围的合适值来强制使用鼠标或键盘输入。

yes-or-no-p 和 y-or-np 都使用 minibuffer。

#+begin_src emacs-lisp
  Function: y-or-n-p prompt ¶
#+end_src

    该函数向用户询问一个问题，期望在 minibuffer 中输入。如果用户输入 y，则返回 t，如果用户输入 n，则返回  ~nil~ 。此函数还接受 SPC 表示是，DEL 表示否。它接受 C-] 和 Cg 退出，因为问题使用了 minibuffer，因此用户可能会尝试使用 C-] 退出。答案是单个字符，不需要 RET 来终止它。大写和小写是等价的。

     ~提出问题~ 是指在 minibuffer 中打印提示，后跟字符串 '(y or n) '。如果输入不是预期答案之一（y、n、SPC、DEL 或退出的内容），则函数响应 ~请回答 y 或 n。~ ，并重复请求。

    此函数实际上使用了 minibuffer，但不允许编辑答案。在提出问题时，光标会移动到迷你缓冲区。

    答案及其含义，甚至是 ~y~ 和 ~n~ ，都不是硬连线的，而是由键映射查询替换映射指定的（请参阅搜索和替换）。特别是，如果用户输入特殊响应recenter、scroll-up、scroll-down、scroll-other-window或scroll-other-window-down（分别绑定到查询中的Cl、Cv、Mv、CMv和CMSv- replace-map)，此函数执行指定的窗口居中或滚动操作，并再次提出问题。

    如果在调用 y-or-np 时将 help-form（请参阅帮助函数）绑定到非  ~nil~  值，则按 help-char 会导致它评估 help-form 并显示结果。help-char 会自动添加到提示中。

#+begin_src emacs-lisp
  Function: y-or-n-p-with-timeout prompt seconds default ¶
#+end_src

    和 y-or-np 一样，除了如果用户在几秒内没有回答，这个函数停止等待并返回默认值。它通过设置计时器来工作；请参阅延迟执行的计时器。参数 seconds 应该是一个数字。

#+begin_src emacs-lisp
  Function: yes-or-no-p prompt ¶
#+end_src

    该函数向用户询问一个问题，期望在 minibuffer 中输入。如果用户输入 ~是~ ，则返回 t，如果用户输入 ~否~ ，则返回  ~nil~ 。用户必须键入 RET 才能完成响应。大写和小写是等价的。

    yes-or-no-p 首先在 minibuffer 中显示提示，然后是 '(yes or no) '。用户必须键入预期的响应之一；否则，该函数会响应 ~请回答是或否。~ ，等待大约两秒钟并重复请求。

    yes-or-no-p 比 y-or-np 需要用户更多的工作，并且适用于更关键的决策。

    这是一个例子：
    #+begin_src emacs-lisp
      (yes-or-no-p "Do you really want to remove everything?")

      ;; After evaluation of the preceding expression,
      ;;   the following prompt appears,
      ;;   with an empty minibuffer:


      ---------- Buffer: minibuffer ----------
      Do you really want to remove everything? (yes or no)
      ---------- Buffer: minibuffer ----------
    #+end_src

    如果用户首先键入 y RET，这是无效的，因为此函数需要整个单词 'yes'，它会通过显示这些提示来响应，在它们之间有一个短暂的停顿：

    #+begin_src emacs-lisp
      ---------- Buffer: minibuffer ----------
      Please answer yes or no.
      Do you really want to remove everything? (yes or no)
      ---------- Buffer: minibuffer ----------
    #+end_src

** 21.8 提出多项选择题
本节描述了用于向用户询问更复杂问题或几个类似问题的工具。

当您有一系列类似的问题要问时，例如 ~您要保存此缓冲区吗？~   对于每个缓冲区，您应该使用 map-y-or-np 来询问问题集合，而不是单独询问每个问题。这为用户提供了一定的便利设施，例如一次回答整个系列的能力。

#+begin_src emacs-lisp
  Function: map-y-or-n-p prompter actor list &optional help action-alist no-cursor-in-echo-area ¶
#+end_src

    此功能向用户提出一系列问题，在回显区域中为每个问题读取一个单字符答案。

    list 的值指定要询问的对象。它应该是对象列表或生成器函数。如果它是一个函数，它将在没有参数的情况下被调用，并且应该返回下一个要询问的对象，或者返回  ~nil~ ，意思是停止提问。

    参数提示器指定如何提出每个问题。如果 prompter 是一个字符串，那么问题文本的计算方式如下：

    #+begin_src emacs-lisp
      (format prompter object)
    #+end_src


    其中 object 是下一个要询问的对象（从列表中获得）。有关格式的更多信息，请参阅格式化字符串。

    如果 prompter 不是字符串，它应该是一个参数（要询问的对象）的函数，并且应该返回该对象的问题文本。如果提示器返回的值是一个字符串，那就是要问用户的问题。该函数还可以返回 t，表示不询问用户就对这个对象进行操作，或者返回  ~nil~ ，表示默默地忽略这个对象。

    参数参与者说如何对用户回答是的对象采取行动。它应该是一个参数的函数，并且将与用户回答是的列表中的每个对象一起调用。

    如果给出参数帮助，它应该是这种形式的列表：

#+begin_src emacs-lisp
  (singular plural action)
#+end_src

    其中单数是包含单数名词的字符串，它描述要作用的单个对象，复数是对应的复数名词，动作是及物动词，描述演员对对象所做的事情。

    如果您不指定帮助，则默认为列表（ ~object~  ~objects~  ~act on~ ）。

    每次提出问题时，用户可以回答如下：

#+begin_src emacs-lisp
  y, Y, or SPC
#+end_src

	 作用于物体
#+begin_src emacs-lisp
  n, N, or DEL
#+end_src

	 跳过对象
#+begin_src emacs-lisp
  !
#+end_src

	 作用于以下所有对象
#+begin_src emacs-lisp
  ESC or q
#+end_src

	 退出（跳过所有以下对象）
#+begin_src emacs-lisp
  . (period)
#+end_src

	 作用于对象然后退出
#+begin_src emacs-lisp
  C-h
#+end_src

	 得到帮助

    这些是 query-replace 接受的相同答案。keymap query-replace-map 定义了它们对 map-y-or-np 和 query-replace 的含义；请参阅搜索和替换。

    您可以使用 action-alist 指定其他可能的答案及其含义。如果提供，action-alist 应该是一个 alist，其元素的格式为 (char function help)。每个 alist 元素都定义了一个附加答案。在每个元素中，char 是一个字符（答案）；函数是一个参数的函数（列表中的一个对象）；帮助是一个字符串。当用户使用 char 响应时，map-y-or-np 调用函数。如果它返回非  ~nil~ ，则认为该对象已被执行，并且 map-y-or-np 前进到列表中的下一个对象。如果它返回  ~nil~ ，则对同一对象重复提示。如果用户请求帮助，帮助中的文本用于描述这些附加答案。

    通常，map-y-or-np 在提示时绑定 cursor-in-echo-area。但是，如果 no-cursor-in-echo-area 不为零，则它不会那样做。

    如果在使用鼠标调用的命令中调用 map-y-or-np——更准确地说，如果 last-nonmenu-event（参见命令循环中的信息）为  ~nil~  或列表——则它使用一个对话框或弹出菜单来提问。在这种情况下，它不使用键盘输入或回声区域。您可以通过将 last-nonmenu-event 绑定到调用周围的合适值来强制使用鼠标或键盘输入。

    map-y-or-np 的返回值是作用于对象的数量。

如果您需要向用户询问一个可能不止 2 个答案的问题，请使用 read-answer。

#+begin_src emacs-lisp
  Function: read-answer question answers ¶
#+end_src

    此功能会提示用户有问题的文本，该文本应以 ~SPC~ 字符结尾。该功能通过将答案附加到问题的末尾来在提示中包含可能的答案。可能的响应以列表形式在答案中提供，其元素具有以下形式：
    #+begin_src emacs-lisp
      (long-answer short-answer help-message)
    #+end_src
    其中 long-answer 是用户响应的完整文本，一个字符串；short-answer 是相同响应、单个字符或功能键的缩写形式；help-message 是描述答案含义的文本。如果变量 read-answer-short 不为零，则提示将显示可能答案的简短变体，并且用户应键入提示中显示的单个字符/键；否则提示将显示答案的长变体，并且用户应键入其中一个答案的全文并按 RET 键结束。如果 use-dialog-box 不为  ~nil~ ，并且此函数由鼠标事件调用，则问题和答案将显示在 GUI 对话框中。

    该函数返回用户选择的长答案的文本，无论提示中显示长答案还是短答案并由用户键入。

    下面是一个使用这个函数的例子：
    #+begin_src emacs-lisp
      (let ((read-answer-short t))
	(read-answer "Foo "
	   '(("yes"  ?y "perform the action")
	     ("no"   ?n "skip to the next")
	     ("all"  ?! "perform for the rest without more questions")
	     ("help" ?h "show help")
	     ("quit" ?q "exit"))))
    #+end_src

#+begin_src emacs-lisp
  Function: read-char-from-minibuffer prompt &optional chars history ¶
#+end_src

    此函数使用 minibuffer 读取并返回单个字符。可选地，它忽略任何不是 chars 成员的输入，这是一个接受的字符列表。history 参数指定要使用的历史列表符号；如果省略或为零，则此函数不使用历史记录。

    如果在调用 read-char-from-minibuffer 时将 help-form（请参阅帮助函数）绑定到非  ~nil~  值，则按 help-char 会导致它评估 help-form 并显示结果。

** 21.9 读取密码
要读取密码以传递给另一个程序，可以使用函数 read-passwd。

#+begin_src emacs-lisp
  Function: read-passwd prompt &optional confirm default ¶
#+end_src

    该函数读取密码，以提示符提示。它不会在用户键入密码时回显密码；相反，它会为密码中的每个字符回显 ~*~ 。如果要应用另一个字符来隐藏密码，请将变量 read-hide-char 与该字符绑定。

    可选参数确认，如果非零，表示读取两次密码并坚持两次必须相同。如果不一样，用户必须一遍又一遍地输入，直到最后两次匹配。

    可选参数 default 指定用户输入空输入时要返回的默认密码。如果 default 为  ~nil~ ，则 read-passwd 在这种情况下返回空字符串。

** 21.10 小缓冲区命令
本节描述了一些用于 minibuffer 的命令。

#+begin_src emacs-lisp
  Command: exit-minibuffer ¶
#+end_src

    此命令退出活动的 minibuffer。它通常绑定到 minibuffer 本地键映射中的键。如果当前缓冲区是一个小缓冲区，而不是活动的小缓冲区，该命令将引发错误。

#+begin_src emacs-lisp
  Command: self-insert-and-exit ¶
#+end_src

    此命令在插入键盘上键入的最后一个字符后退出活动的小缓冲区（在 last-command-event 中找到；请参阅命令循环中的信息）。

#+begin_src emacs-lisp
  Command: previous-history-element n ¶
#+end_src

    此命令将 minibuffer 内容替换为第 n 个先前（较旧）历史元素的值。

#+begin_src emacs-lisp
  Command: next-history-element n ¶
#+end_src

    此命令将 minibuffer 内容替换为第 n 个最近的历史元素的值。历史中的位置可以超出当前位置并调用 ~未来历史~ （请参阅​​使用 Minibuffer 读取文本字符串）。

#+begin_src emacs-lisp
  Command: previous-matching-history-element pattern n ¶
#+end_src

    此命令将 minibuffer 内容替换为匹配模式（正则表达式）的第 n 个先前（较旧）历史元素的值。

#+begin_src emacs-lisp
  Command: next-matching-history-element pattern n ¶
#+end_src

    此命令将 minibuffer 内容替换为匹配模式（正则表达式）的第 n 个下一个（较新）历史元素的值。

#+begin_src emacs-lisp
  Command: previous-complete-history-element n ¶
#+end_src

    此命令将 minibuffer 内容替换为第 n 个先前（较旧）历史元素的值，该历史元素在该点之前完成了 minibuffer 的当前内容。

#+begin_src emacs-lisp
  Command: next-complete-history-element n ¶
#+end_src

    此命令将 minibuffer 内容替换为第 n 个下一个（较新）历史元素的值，该历史元素在该点之前完成了 minibuffer 的当前内容。

#+begin_src emacs-lisp
  Command: goto-history-element nabs ¶
#+end_src

    此函数将 minibuffer 历史的元素放入 minibuffer。参数 nabs 以降序指定绝对历史位置，其中 0 表示当前元素，正数 n 表示前第 n 个元素。NABS 为负数 -n 表示 ~未来历史~ 的第 n 个条目。

** 21.11 小缓冲窗口
这些函数访问和选择 minibuffer 窗口，测试它们是否处于活动状态并控制它们如何调整大小。

#+begin_src emacs-lisp
  Function: minibuffer-window &optional frame ¶
#+end_src

    此函数返回用于帧帧的 minibuffer 窗口。如果 frame 为  ~nil~ ，则表示选定的帧。

    请注意，一个帧使用的 minibuffer 窗口不必是该帧的一部分——一个没有自己的 minibuffer 的帧必须使用某个其他帧的 minibuffer 窗口。可以通过设置该帧的 minibuffer frame 参数来更改 minibuffer-less 帧的 minibuffer 窗口（请参阅缓冲区参数）。

#+begin_src emacs-lisp
  Function: set-minibuffer-window window ¶
#+end_src

    此函数将 window 指定为要使用的 minibuffer 窗口。如果您将文本放入其中而不调用通常的 minibuffer 命令，这会影响 minibuffer 的显示位置。它对通常的 minibuffer 输入函数没有影响，因为它们都是从根据所选帧选择 minibuffer 窗口开始的。

#+begin_src emacs-lisp
  Function: window-minibuffer-p &optional window ¶
#+end_src

    如果 window 是 minibuffer 窗口，此函数返回 t。窗口默认为选定的窗口。

以下函数返回显示当前活动的 minibuffer 的窗口。

#+begin_src emacs-lisp
  Function: active-minibuffer-window ¶
#+end_src

    此函数返回当前活动的 minibuffer 的窗口，如果没有活动的 minibuffer，则返回  ~nil~ 。

通过将给定窗口与 (minibuffer-window) 的结果进行比较来确定给定窗口是否显示当前活动的 minibuffer 是不够的，因为如果有超过一帧，则可能有多个 minibuffer 窗口。

#+begin_src emacs-lisp
  Function: minibuffer-window-active-p window ¶
#+end_src

    如果窗口显示当前活动的 minibuffer，此函数返回非  ~nil~ 。

以下两个选项控制是否自动调整 minibuffer 窗口的大小以及在此过程中它们可以变得多大。

#+begin_src emacs-lisp
  User Option: resize-mini-windows ¶
#+end_src

    此选项指定是否自动调整 minibuffer 窗口的大小。默认值是 grow-only，这意味着默认情况下，minibuffer 窗口会自动扩展以适应它显示的文本，并在 minibuffer 变空后立即缩回一行。如果值为 t，Emacs 将始终尝试使 minibuffer 窗口的高度适合它显示的文本（最少一行）。如果该值为  ~nil~ ，则 minibuffer 窗口永远不会自动更改大小。在这种情况下，窗口大小调整命令（请参阅调整窗口大小）可用于调整其高度。

#+begin_src emacs-lisp
  User Option: max-mini-window-height ¶
#+end_src

    此选项为自动调整 minibuffer 窗口大小提供了最大高度。浮点数将最大高度指定为框​​架高度的一部分；一个整数指定以框架的规范字符高度为单位的最大高度（请参阅框架字体）。默认值为 0.25。

请注意，上述两个变量的值在显示时生效，因此将它们绑定在产生回显区域消息的代码周围将不起作用。如果您想在显示长消息时阻止调整 minibuffer 窗口的大小，请改为绑定 message-truncate-lines 变量（请参阅回声区域自定义）。

选项 resize-mini-windows 不会影响 minibuffer-only 帧的行为（请参阅帧布局）。以下选项也允许自动调整此类框架的大小。

#+begin_src emacs-lisp
  User Option: resize-mini-frames ¶
#+end_src

    如果为  ~nil~ ，则永远不会自动调整 minibuffer-only 帧的大小。

    如果这是一个函数，则调用该函数并使用仅用于调整大小的 minibuffer 帧作为唯一参数。在调用此函数时，该帧的 minibuffer 窗口的缓冲区是下次重新显示该窗口时将显示其内容的缓冲区。该函数有望以某种适当的方式使帧适合缓冲区。

    任何其他非零值意味着通过调用 fit-mini-frame-to-buffer 来调整仅 minibuffer 帧的大小，该函数的行为类似于 fit-frame-to-buffer（请参阅调整窗口大小），但不会去除前导或尾随空缓冲区文本中的行。

** 21.12 小缓冲区内容
这些函数访问 minibuffer 提示和内容。

#+begin_src emacs-lisp
  Function: minibuffer-prompt ¶
#+end_src

    此函数返回当前活动的 minibuffer 的提示字符串。如果没有 minibuffer 处于活动状态，则返回  ~nil~ 。

#+begin_src emacs-lisp
  Function: minibuffer-prompt-end ¶
#+end_src

    如果 minibuffer 是当前的，则此函数返回 minibuffer 提示结束的当前位置。否则，它返回最小的有效缓冲区位置。

#+begin_src emacs-lisp
  Function: minibuffer-prompt-width ¶
#+end_src

    如果 minibuffer 是当前的，则此函数返回 minibuffer 提示的当前显示宽度。否则，它返回零。

#+begin_src emacs-lisp
  Function: minibuffer-contents ¶
#+end_src

    如果 minibuffer 是当前的，则此函数将 minibuffer 的可编辑内容（即除了提示符之外的所有内容）作为字符串返回。否则，它返回当前缓冲区的全部内容。

#+begin_src emacs-lisp
  Function: minibuffer-contents-no-properties ¶
#+end_src

    这类似于 minibuffer-contents，只是它不复制文本属性，只是复制字符本身。请参阅文本属性。

#+begin_src emacs-lisp
  Command: delete-minibuffer-contents ¶
#+end_src

    如果 minibuffer 是当前的，此命令将擦除 minibuffer 的可编辑内容（即除了提示符之外的所有内容）。否则，它会擦除​​整个当前缓冲区。

** 21.13 递归小缓冲区
这些函数和变量处理递归小缓冲区（请参阅递归编辑）：

#+begin_src emacs-lisp
  Function: minibuffer-depth ¶
#+end_src

    此函数返回 minibuffer 的当前激活深度，一个非负整数。如果没有活动的小缓冲区，则返回零。
#+begin_src emacs-lisp
  User Option: enable-recursive-minibuffers ¶
#+end_src

    如果此变量不为  ~nil~ ，即使在 minibuffer 处于活动状态时，您也可以调用使用 minibuffers 的命令（例如 find-file）。这样的调用为新的 minibuffer 产生了一个递归的编辑级别。默认情况下，当您编辑内层 minibuffer 时，外层 minibuffer 是不可见的。如果将 minibuffer-follows-selected-frame 设置为  ~nil~ ，则可以同时在多个帧上显示 minibuffer。请参阅 (emacs)基本迷你缓冲区。

    如果此变量为  ~nil~ ，则当 minibuffer 处于活动状态时，您无法调用 minibuffer 命令，即使您切换到另一个窗口来执行此操作也是如此。

如果命令名称具有非  ~nil~  的属性 enable-recursive-minibuffers，则该命令可以使用 minibuffer 来读取参数，即使它是从 minibuffer 调用的。命令也可以通过在交互式声明中将 enable-recursive-minibuffers 绑定到 t 来实现这一点（请参阅使用交互式）。minibuffer 命令 next-matching-history-element（通常是 minibuffer 中的 Ms）执行后者。

** 21.14 抑制交互
有时能够将 Emacs 作为无头服务器进程运行以响应通过网络连接给出的命令是很有用的。然而，Emacs 主要是一个交互式使用的平台，因此在某些异常情况下，许多命令会提示用户进行反馈。这使得这个用例变得更加困难，因为服务器进程只会挂起等待用户输入。

将禁止交互变量绑定到非  ~nil~  的东西会使 Emacs 发出禁止交互错误而不是提示，然后服务器进程可以使用它来处理这些情况。

这是一个典型的用例：
#+begin_src emacs-lisp
(let ((inhibit-interaction t))
  (respond-to-client
   (condition-case err
       (my-client-handling-function)
     (inhibited-interaction err))))
#+end_src


如果 my-client-handling-function 最终调用了向用户询问某事的内容（通过 y-or-np 或 read-from-minibuffer 等），则会发出禁止交互错误的信号。然后服务器代码捕获该错误并将其报告给客户端。
** 21.15 小缓冲区杂记
#+begin_src emacs-lisp
  Function: minibufferp &optional buffer-or-name live ¶
#+end_src

    如果 buffer-or-name 是一个 minibuffer，这个函数返回非  ~nil~ 。如果 buffer-or-name 被省略或为零，它会测试当前缓冲区。当 live 为非  ~nil~  时，仅当 buffer-or-name 是活动的 minibuffer 时，该函数才返回非  ~nil~ 。

#+begin_src emacs-lisp
  Variable: minibuffer-setup-hook ¶
#+end_src

    这是一个正常的钩子，只要进入一个小缓冲区就会运行。请参阅挂钩。

#+begin_src emacs-lisp
  Macro: minibuffer-with-setup-hook function &rest body ¶
#+end_src

    此宏在安排通过 minibuffer-setup-hook 调用指定函数后执行主体。默认情况下，在 minibuffer-setup-hook 列表中的其他函数之前调用 function，但如果 function 是 (:append func) 形式，则在其他 hook 函数之后调用 func。

    正文形式不应多次使用 minibuffer。如果 minibuffer 以递归方式重新进入，函数将只被调用一次，用于 minibuffer 的最外层使用。

#+begin_src emacs-lisp
  Variable: minibuffer-exit-hook ¶
#+end_src

    这是一个正常的钩子，只要退出 minibuffer 就会运行。请参阅挂钩。

#+begin_src emacs-lisp
  Variable: minibuffer-help-form ¶
#+end_src

    此变量的当前值用于在 minibuffer 中本地重新绑定帮助表单（请参阅帮助函数）。

#+begin_src emacs-lisp
  Variable: minibuffer-scroll-window ¶
#+end_src

    如果这个变量的值是非零，它应该是一个窗口对象。当在 minibuffer 中调用函数 scroll-other-window 时，它会滚动这个窗口（参见 Textual Scrolling）。

#+begin_src emacs-lisp
  Function: minibuffer-selected-window ¶
#+end_src

    此函数返回在选择 minibuffer 窗口之前选择的窗口。如果选定的窗口不是 minibuffer 窗口，则返回  ~nil~ 。

#+begin_src emacs-lisp
  Function: minibuffer-message string &rest args ¶
#+end_src

    此函数在 minibuffer 文本的末尾临时显示字符串几秒钟，或直到下一个输入事件到达，以先到者为准。变量 minibuffer-message-timeout 指定在没有输入的情况下等待的秒数。默认为 2。如果 args 为非  ~nil~ ，则通过 format-message 传递 string 和 args 获得实际消息。请参阅格式化字符串。

#+begin_src emacs-lisp
  Command: minibuffer-inactive-mode ¶
#+end_src

    这是非活动小缓冲区中使用的主要模式。它使用键盘映射 minibuffer-inactive-mode-map。如果 minibuffer 在单独的帧中，这可能很有用。请参阅小缓冲区和帧。
