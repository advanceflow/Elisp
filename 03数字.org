#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: elegantpaper
#+OPTIONS: prop:t
#+OPTIONS: ^:nil

* DONE 3 数字

GNU Emacs 支持两种数字数据类型：整数和浮点数。  整数是整数，例如 -3、0、7、13 和 511。浮点数是带有小数部分的数字，例如 -4.5、0.0 和 2.71828。  它们也可以用指数符号表示：“1.5e2”与“150.0”相同；  在这里，“e2”代表 10 的二次方，即乘以 1.5。  整数计算是精确的。  浮点计算通常涉及舍入误差，因为数字具有固定的精度。

** DONE 3.1 整数基础

Lisp 阅读器将整数读取为具有可选初始符号和可选最后句点的十进制数字的非空序列。

#+begin_src emacs-lisp
   1               ; The integer 1.
   1.              ; The integer 1.
  +1               ; Also the integer 1.
  -1               ; The integer -1.
   0               ; The integer 0.
  -0               ; The integer 0.
#+end_src

以 10 为基数的整数的语法由 '#' 后跟一个基数指示，后跟一个或多个数字组成。  基数指示是“b”表示二进制，“o”表示八进制，“x”表示十六进制，“radixr”表示基数。  因此，'#binteger' 以二进制读取整数，而 '#radixrinteger' 以 radix radix 读取整数。  radix 的允许值从 2 到 36，允许的数字是从 '0'-'9'、'A'-'Z' 中取出的第一个 radix 字符。  字母大小写被忽略，没有初始符号或最后一个句点。  例如：

#+begin_src emacs-lisp
  #b101100 ⇒ 44
  #o54 ⇒ 44
  #x2c ⇒ 44
  #24r1k ⇒ 44
#+end_src

要了解各种函数如何处理整数，尤其是位运算符（请参阅整数的位运算），查看二进制形式的数字通常会有所帮助。

在二进制中，十进制整数 5 如下所示：

#+begin_src emacs-lisp
  …000101
#+end_src
（省略号“...”在概念上代表与前导位匹配的无限数量的位；这里是无限数量的 0 位。后面的示例也使用此“...”表示法。）

整数 -1 如下所示：

#+begin_src emacs-lisp
  …111111
#+end_src

-1 表示为全1。  （这称为二进制补码表示法。）

从 -1 中减去 4 返回负整数 -5。  在二进制中，十进制整数 4 是 100。因此，-5 看起来像这样：

#+begin_src emacs-lisp
  …111011
#+end_src

本章中描述的许多函数都接受参数的标记来代替数字。  （请参阅标记。）由于此类函数的实际参数可能是数字或标记，因此我们通常将这些参数命名为数字或标记。  当参数值为标记时，使用其位置值并忽略其缓冲区。

在 Emacs Lisp 中，文本字符由整数表示。  介于零和 (max-char) 的值之间的任何整数（包括端点）都被认为是有效的字符。  请参阅字符代码。

Emacs Lisp 中的整数不受机器字长的限制。  然而，在底层，有两种整数：较小的整数，称为 fixnums，以及较大的整数，称为 bignums。  尽管 Emacs Lisp 代码通常不应该依赖于整数是 fixnum 还是 bignum，但旧的 Emacs 版本仅支持 fixnums，Emacs 中的某些函数仍然只接受 fixnums，并且旧的 Emacs Lisp 代码在给定 bignums 时可能会出现问题。  例如，虽然较旧的 Emacs Lisp 代码可以安全地将整数与 eq 进行数值相等比较，但 bignums 的存在意味着现在应该使用 eql 和 = 等相等谓词来比较整数。

bignums 的值范围受主内存量、机器特性（例如用于表示 bignum 指数的字的大小）以及整数宽度变量的限制。  这些限制通常比 fixnums 的限制要宽松得多。  bignum 在数值上永远不会等于 fixnum。  Emacs 总是将 fixnum 范围内的整数表示为 fixnum，而不是 bignum。

fixnum 的值范围取决于机器。  最小范围是 -536,870,912 到 536,870,911（30 位；即 -2**29 到 2**29 - 1），但许多机器提供的范围更广。

#+begin_src emacs-lisp
  Variable: most-positive-fixnum
#+end_src
    这个变量的值是 Emacs Lisp 可以处理的最大的“小”整数。  典型值为 32 位平台上的 2**29 - 1 和 64 位平台上的 2**61 - 1。


#+begin_src emacs-lisp
  Variable: most-negative-fixnum
#+end_src
    这个变量的值是 Emacs Lisp 可以处理的数字最小的“小”整数。  它是负面的。  典型值为 32 位平台上的 -2**29 和 64 位平台上的 -2**61。

#+begin_src emacs-lisp
  Variable: integer-width
#+end_src
    该变量的值是一个非负整数，用于控制 Emacs 在计算大整数时是否发出范围错误信号。  绝对值小于 2**n 的整数（其中 n 是此变量的值）不表示范围错误。  尝试创建更大的整数通常表示范围错误，但如果可以廉价地创建更大的整数，则可能没有信号。  如果计算创建巨大的整数，则将此变量设置为较大的数字可能会很昂贵。

** DONE 3.2 浮点基础
  CLOSED: [2022-05-24 Tue 09:54]
  :LOGBOOK:
   - State "DONE"       from "DONE"       [2022-05-24 Tue 09:54]
   :END:

浮点数对于表示非整数的数字很有用。  浮点数的范围与您使用的机器上的 C 数据类型 double 的范围相同。  在 Emacs 支持的所有计算机上，这是 IEEE binary64 浮点格式，由 IEEE Std 754-2019 标准化，并在 David Goldberg 的论文“What Every Computer Scientist Should Know About Floating-Point Arithmetic”中进一步讨论。  在现代平台上，浮点运算严格遵循 IEEE-754 标准；  然而，在一些过时的平台上，结果并不总是正确四舍五入，尤其是 32 位 x86。

浮点数的读取语法需要小数点、指数或两者。  可选符号（“+”或“-”）位于数字及其指数之前。  例如'1500.0', '+15e2', '15.0e+2', '+1500000e-3', '.15e4' 是浮点数1500的五种写法，它们都是等价的.  与 Common Lisp 一样，Emacs Lisp 要求在没有指数的浮点数中小数点后至少有一位数字；  “1500。”  是整数，而不是浮点数。

Emacs Lisp 将 -0.0 视为在数值上等于普通的零，对于像 = 这样的数值比较。  这遵循 IEEE 浮点标准，即 -0.0 和 0.0 在数值上相等，即使其他操作可以区分它们。

IEEE 浮点标准支持正无穷大和负无穷大作为浮点值。  它还提供了一类称为 NaN 或“非数字”的值；  在没有正确答案的情况下，数值函数会返回此类值。  例如，(/0.0 0.0) 返回一个 NaN。  NaN 在数值上永远不等于任何值，甚至不等于它自己。  NaN 带有一个符号和一个有效数字，非数字函数在两个 NaN 的符号和有效数字一致时将其视为相等。  NaN 的有效位是机器相关的，它们的字符串表示中的数字也是如此。

当涉及到 NaN 和有符号零时，诸如 eql、equal、sxhash-eql、sxhash-equal 和 gethash 之类的非数字函数确定值是否不可区分，而不是它们在数值上是否相等。  例如，当 x 和 y 是相同的 NaN 时，(equal xy) 返回 t，而 (= xy) 使用数值比较并返回 nil；  相反，(equal 0.0 -0.0) 返回 nil，而 (= 0.0 -0.0) 返回 t。

以下是这些特殊浮点值的读取语法：

#+begin_src emacs-lisp
  infinity
#+end_src
    “1.0e+INF”和“-1.0e+INF”

#+begin_src emacs-lisp
not-a-number
#+end_src
    “0.0e+NaN”和“-0.0e+NaN”

以下函数专门用于处理浮点数：


#+begin_src emacs-lisp
  Function: isnan x
#+end_src

    如果它的浮点参数是 NaN，则此谓词返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: frexp x
#+end_src

    此函数返回一个 cons 单元格 (s . e)，其中 s 和 e 分别是浮点数 x 的有效数和指数。

    如果 x 是有限的，则 s 是介于 0.5（含）和 1.0（不含）之间的浮点数，e 是整数，x = s * 2**e。  如果 x 为零或无穷大，则 s 与 x 相同。  如果 x 是 NaN，则 s 也是 NaN。  如果 x 为零，则 e 为 0。

#+begin_src emacs-lisp
  Function: ldexp s e
#+end_src
    给定一个数字有效数 s 和一个整数指数 e，此函数返回浮点数 s * 2**e。

#+begin_src emacs-lisp
  Function: copysign x1 x2
#+end_src
    此函数将 x2 的符号复制到 x1 的值，并返回结果。  x1 和 x2 必须是浮点数。

#+begin_src emacs-lisp
  Function: logb x
#+end_src
    此函数返回 x 的二进制指数。  更准确地说，如果 x 是有限且非零的，则该值是 |x| 的以 2 为底的对数，向下舍入为整数。  如果 x 为零或无穷大，则值为无穷大；  如果 x 是 NaN，则值为 NaN。

    #+begin_src emacs-lisp
      (logb 10)
	   ⇒ 3
      (logb 10.0e20)
	   ⇒ 69
      (logb 0)
	   ⇒ -1.0e+INF
    #+end_src
** DONE 3.3 数字的类型谓词
  CLOSED: [2022-05-24 Tue 09:54]
  :LOGBOOK:
   - State "DONE"       from "DONE"       [2022-05-24 Tue 09:54]
   :END:

本节中的函数测试数字或特定类型的数字。  函数 integerp 和 floatp 可以将任何类型的 Lisp 对象作为参数（否则它们不会有太大用处），但 zerop 谓词需要一个数字作为参数。  另请参阅标记上的谓词中的 integer-or-marker-p 和 number-or-marker-p。

#+begin_src emacs-lisp
  Function: bignump object
#+end_src
    该谓词测试其参数是否为大整数，如果是则返回 t，否则返回 nil。  与小整数不同，大整数可以是 = 或 eql，即使它们不是 eq。

#+begin_src emacs-lisp
  Function: fixnump object
#+end_src
    此谓词测试其参数是否为小整数，如果是则返回 t，否则返回 nil。  小整数可以与 eq 进行比较。

#+begin_src emacs-lisp
  Function: floatp object
#+end_src
    该谓词测试其参数是否为浮点数，如果是则返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: integerp object
#+end_src
    该谓词测试其参数是否为整数，如果是则返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: numberp object
#+end_src

    此谓词测试其参数是否为数字（整数或浮点数），如果是则返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: natnump object
#+end_src

    该谓词（其名称来自短语“自然数”）测试其参数是否为非负整数，如果是则返回 t，否则返回 nil。  0 被认为是非负数。

    Wholenump 是 natnump 的同义词。

#+begin_src emacs-lisp
  Function: zerop number
#+end_src
    该谓词测试其参数是否为零，如果是则返回 t，否则返回 nil。  参数必须是一个数字。

    #+begin_src emacs-lisp
      (zerop x) is equivalent to (= x 0)
    #+end_src

** DONE 3.4 数字比较
  CLOSED: [2022-05-24 Tue 09:54]
  :LOGBOOK:
   - State "DONE"       from "DONE"       [2022-05-24 Tue 09:54]
   :END:

要测试数字是否相等，通常应该使用 = 而不是非数字比较谓词，如 eq、eql 和 equal。  不同的浮点数和大整数对象可以在数值上相等。  如果你用 eq 来比较它们，你测试它们是否是同一个对象；  如果使用 eql 或 equal，则测试它们的值是否无法区分。  相反，= 使用数字比较，当非数字比较返回 nil 时，有时会返回 t，反之亦然。  请参阅浮点基础知识。

在 Emacs Lisp 中，如果两个 fixnum 在数值上相等，则它们是同一个 Lisp 对象。  也就是说，eq 等价于 = on fixnums。  有时使用 eq 比较未知值与固定值比较方便，因为如果未知值不是数字，eq 不会报告错误——它接受任何类型的参数。  相反，如果参数不是数字或标记，则 = 表示错误。  但是，如果可以，最好使用 =，即使是比较整数也是如此。

有时将数字与 eql 或相等进行比较很有用，如果两个数字具有相同的数据类型（均为整数，或均为浮点数）和相同的值，则将它们视为相等。  相比之下，= 可以将整数和浮点数视为相等。  请参见等式谓词。

还有另一个问题：因为浮点运算并不精确，所以检查浮点值是否相等通常是个坏主意。  通常最好测试近似相等。  这是一个执行此操作的函数：


#+begin_src emacs-lisp
  (defvar fuzz-factor 1.0e-6)
  (defun approx-equal (x y)
    (or (= x y)
	(< (/ (abs (- x y))
	      (max (abs x) (abs y)))
	   fuzz-factor)))
#+end_src

#+begin_src emacs-lisp
  Function: = number-or-marker &rest number-or-markers
#+end_src

    此函数测试其所有参数在数值上是否相等，如果相等则返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: eql value1 value2
#+end_src

    此函数的作用类似于 eq，除非两个参数都是数字。  它按类型和数值比较数字，因此 (eql 1.0 1) 返回 nil，但 (eql 1.0 1.0) 和 (eql 1 1) 都返回 t。  这可用于比较大整数和小整数。  具有相同符号、指​​数和分数的浮点值是 eql。  这与数值比较不同：(eql 0.0 -0.0) 返回 nil，(eql 0.0e+NaN 0.0e+NaN) 返回 t，而 = 则相反。

#+begin_src emacs-lisp
  Function: /= number-or-marker1 number-or-marker2
#+end_src

    此函数测试其参数在数值上是否相等，如果不相等则返回 t，如果相等则返回 nil。

#+begin_src emacs-lisp
  Function: < number-or-marker &rest number-or-markers
#+end_src
    此函数测试每个参数是否严格小于以下参数。  如果是，则返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: <= number-or-marker &rest number-or-markers
#+end_src
    此函数测试每个参数是否小于或等于以下参数。  如果是，则返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: > number-or-marker &rest number-or-markers
#+end_src
    此函数测试每个参数是否严格大于以下参数。  如果是，则返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: >= number-or-marker &rest number-or-markers
#+end_src
    此函数测试每个参数是否大于或等于以下参数。  如果是，则返回 t，否则返回 nil。

#+begin_src emacs-lisp
  Function: max number-or-marker &rest numbers-or-markers
#+end_src

    此函数返回其参数中的最大值。

    #+begin_src emacs-lisp
      (max 20)
	   ⇒ 20
      (max 1 2.5)
	   ⇒ 2.5
      (max 1 3 2.5)
	   ⇒ 3
    #+end_src

#+begin_src emacs-lisp
  Function: min number-or-marker &rest numbers-or-markers
#+end_src
    此函数返回其参数中的最小者。

    #+begin_src emacs-lisp
      (min -4 1)
	   ⇒ -4
    #+end_src

#+begin_src emacs-lisp
  Function: abs number
#+end_src
    该函数返回数字的绝对值。

** DONE 3.5 数值转换
  CLOSED: [2022-05-24 Tue 09:54]
  :LOGBOOK:
   - State "DONE"       from "DONE"       [2022-05-24 Tue 09:54]
   :END:

要将整数转换为浮点数，请使用函数 float。

#+begin_src emacs-lisp
Function: float number
#+end_src

    这将返回转换为浮点数的数字。  如果 number 已经是浮点数，则 float 将其原封不动地返回。

有四个函数可以将浮点数转换为整数；  它们的舍入方式不同。  都接受一个参数编号和一个可选的参数除数。  两个参数都可以是整数或浮点数。  除数也可能为零。  如果 divisor 为 nil 或省略，这些函数将数字转换为整数，如果它已经是整数，则将其原样返回。  如果 divisor 不为 nil，则它们将数字除以除数并将结果转换为整数。  如果除数为零（无论是整数还是浮点数），Emacs 都会发出算术错误错误信号。

#+begin_src emacs-lisp
Function: truncate number &optional divisor
#+end_src

    这将返回数字，通过向零舍入转换为整数。

    #+begin_src emacs-lisp
(truncate 1.2)
     ⇒ 1
(truncate 1.7)
     ⇒ 1
(truncate -1.2)
     ⇒ -1
(truncate -1.7)
     ⇒ -1

    #+end_src


#+begin_src emacs-lisp
Function: floor number &optional divisor
#+end_src

    这将返回数字，通过向下舍入（向负无穷大）转换为整数。

    如果指定了除数，则使用与 mod 对应的除法运算，向下舍入。

    #+begin_src emacs-lisp
(floor 1.2)
     ⇒ 1
(floor 1.7)
     ⇒ 1
(floor -1.2)
     ⇒ -2
(floor -1.7)
     ⇒ -2
(floor 5.99 3)
     ⇒ 1
    #+end_src


#+begin_src emacs-lisp
  Function: ceiling number &optional divisor
#+end_src
    这将返回数字，通过向上舍入（向正无穷大）转换为整数。

    #+begin_src emacs-lisp
      (ceiling 1.2)
	   ⇒ 2
      (ceiling 1.7)
	   ⇒ 2
      (ceiling -1.2)
	   ⇒ -1
      (ceiling -1.7)
	   ⇒ -1

    #+end_src

#+begin_src emacs-lisp
  Function: round number &optional divisor
#+end_src


    这将返回数字，通过向最接近的整数舍入转换为整数。  舍入两个整数之间等距的值会返回偶数。

    #+begin_src emacs-lisp
      (round 1.2)
	   ⇒ 1
      (round 1.7)
	   ⇒ 2
      (round -1.2)
	   ⇒ -1
      (round -1.7)
	   ⇒ -2
    #+end_src

** DONE 3.6 算术运算
  CLOSED: [2022-05-24 Tue 09:54]
  :LOGBOOK:
   - State "DONE"       from "DONE"       [2022-05-24 Tue 09:54]
   :END:

Emacs Lisp 提供了传统的四种算术运算（加法、减法、乘法和除法），以及余数和模数函数，以及加减 1 的函数。除了 %，这些函数中的每一个都接受整数和浮点数参数，如果任何参数是浮点数，则返回一个浮点数。

#+begin_src emacs-lisp
  Function: 1+ number-or-marker
#+end_src


    此函数返回数字或标记加 1。例如，

    #+begin_src emacs-lisp
      (setq foo 4)
	   ⇒ 4
      (1+ foo)
	   ⇒ 5
    #+end_src

    此函数与 C 运算符 ++ 不同——它不会增加变量。  它只是计算一个总和。  因此，如果我们继续，

    #+begin_src emacs-lisp
foo
     ⇒ 4

    #+end_src


    如果要增加变量，则必须使用 setq，如下所示：

    #+begin_src emacs-lisp
(setq foo (1+ foo))
     ⇒ 5

    #+end_src


#+begin_src emacs-lisp
Function: 1- number-or-marker
#+end_src

    此函数返回数字或标记减 1。

#+begin_src emacs-lisp
Function: + &rest numbers-or-markers
#+end_src

    该函数将其参数相加。  当不给定参数时，+ 返回 0。

    #+begin_src emacs-lisp
      (+)
	   ⇒ 0
      (+ 1)
	   ⇒ 1
      (+ 1 2 3 4)
	   ⇒ 10
    #+end_src


#+begin_src emacs-lisp
Function: - &optional number-or-marker &rest more-numbers-or-markers
#+end_src

    - 函数有两个用途：否定和减法。  当 - 有一个参数时，该值是参数的负数。  当有多个参数时， - 从 number-or-marker 中累积减去每个 more-numbers-or-markers。  如果没有参数，则结果为 0。

      #+begin_src emacs-lisp
(- 10 1 2 3 4)
     ⇒ 0
(- 10)
     ⇒ -10
(-)
     ⇒ 0
      #+end_src


#+begin_src emacs-lisp
  Function: * &rest numbers-or-markers
#+end_src

    此函数将其参数相乘，并返回乘积。  如果不给定参数，* 返回 1。
    #+begin_src emacs-lisp
      (*)
	   ⇒ 1
      (* 1)
	   ⇒ 1
      (* 1 2 3 4)
	   ⇒ 24
    #+end_src



#+begin_src emacs-lisp
  Function: / number &rest divisors
#+end_src

    对于一个或多个除数，此函数依次将数字除以除数中的每个除数，并返回商。  在没有除数的情况下，此函数返回 1/number，即 number 的乘法倒数。  每个参数可以是一个数字或一个标记。

    如果所有参数都是整数，则结果是整数，通过在每次除法后将商向零舍入获得。

    #+begin_src emacs-lisp


      (/ 6 2)
	   ⇒ 3

      (/ 5 2)
	   ⇒ 2

      (/ 5.0 2)
	   ⇒ 2.5

      (/ 5 2.0)
	   ⇒ 2.5

      (/ 5.0 2.0)
	   ⇒ 2.5

      (/ 4.0)
	   ⇒ 0.25

      (/ 4)
	   ⇒ 0

      (/ 25 3 2)
	   ⇒ 4

      (/ -17 6)
	   ⇒ -2

    #+end_src

    如果你将一个整数除以整数 0，Emacs 会发出一个 arith-error 错误信号（请参阅错误）。  非零数除以零的浮点除法产生正无穷或负无穷（请参阅浮点基础）。

#+begin_src emacs-lisp
  Function: % dividend divisor
#+end_src

    此函数返回除数除以除数后的整数余数。  参数必须是整数或标记。

    对于任何两个整数被除数和除数，

    #+begin_src emacs-lisp
      (+ (% dividend divisor)
	 (* (/ dividend divisor) divisor))
    #+end_src


    如果除数不为零，则始终等于被除数。
    #+begin_src emacs-lisp
      (% 9 4)
	   ⇒ 1
      (% -9 4)
	   ⇒ -1
      (% 9 -4)
	   ⇒ 1
      (% -9 -4)
	   ⇒ -1
    #+end_src



#+begin_src emacs-lisp
  Function: mod dividend divisor
#+end_src
    该函数返回被除数模除数的值；  换句话说，被除数除以除数后的余数，但符号与除数相同。  参数必须是数字或标记。

    与 % 不同，mod 允许浮点参数；  它将商向下（朝向负无穷大）四舍五入为整数，并使用该商来计算余数。

    如果除数为零，如果两个参数都是整数，则 mod 发出算术错误错误信号，否则返回 NaN。

    #+begin_src emacs-lisp
      (mod 9 4)
	   ⇒ 1

      (mod -9 4)
	   ⇒ 3

      (mod 9 -4)
	   ⇒ -3

      (mod -9 -4)
	   ⇒ -1

      (mod 5.5 2.5)
	   ⇒ .5
    #+end_src

    对于任何两个数字的除数和除数，

    #+begin_src emacs-lisp
      (+ (mod dividend divisor)
	 (* (floor dividend divisor) divisor))
    #+end_src

    总是等于被除数，如果任一参数是浮点数，则会出现舍入错误；如果被除数是整数且除数为 0，则会出现算术错误。关于下限，请参阅数值转换。

** DONE 3.7 舍入操作
  CLOSED: [2022-05-24 Tue 09:54]
  :LOGBOOK:
   - State "DONE"       from "DONE"       [2022-05-24 Tue 09:54]
   :END:

函数 ffloor、fceiling、fround 和 ftruncate 采用浮点参数并返回其值为附近整数的浮点结果。  ffloor 返回下面最接近的整数；  fceiling，上面最接近的整数；  ftruncate，向零方向最接近的整数；  fround，最接近的整数。

#+begin_src emacs-lisp
  Function: ffloor float
#+end_src


    此函数将浮点数舍入到下一个较低的整数值，并将该值作为浮点数返回。

#+begin_src emacs-lisp
  Function: fceiling float
#+end_src

    此函数将浮点数舍入到下一个更高的整数值，并将该值作为浮点数返回。

#+begin_src emacs-lisp
  Function: ftruncate float
#+end_src

    此函数将浮点数向零舍入为整数值，并将该值作为浮点数返回。

#+begin_src emacs-lisp
  Function: fround float
#+end_src

    此函数将浮点数舍入为最接近的整数值，并将该值作为浮点数返回。  舍入两个整数之间等距的值会返回偶数。

** DONE 3.8 整数的按位运算
  CLOSED: [2022-05-24 Tue 09:54]
  :LOGBOOK:
   - State "DONE"       from "DONE"       [2022-05-24 Tue 09:54]
   :END:

在计算机中，整数表示为二进制数、位序列（数字为 0 或 1）。  从概念上讲，左侧的位序列是无限的，最高有效位全为零或全一。  逐位运算作用于此类序列的各个位。  例如，shifting 将整个序列向左或向右移动一个或多个位置，再现移动过的相同模式。

Emacs Lisp 中的按位运算仅适用于整数。

#+begin_src emacs-lisp
  Function: ash integer1 count
#+end_src


    ash（算术移位）将 integer1 中的位移动到左侧 count 位，如果 count 为负数，则向右移动。  左移在右边引入零位；  右移丢弃最右边的位。  考虑为整数运算，ash 将 integer1 乘以 2**count，然后通过向下舍入将结果转换为整数，朝向负无穷大。

    以下是 ash 的示例，将位模式向左和向右移动一个位置。  这些示例仅显示了二进制模式的低位；  前导位都与所示的最高位一致。  如您所见，左移一相当于乘以二，而右移一相当于除以二，然后向负无穷大舍入。

    #+begin_src emacs-lisp


(ash 7 1) ⇒ 14
;; Decimal 7 becomes decimal 14.
…000111
     ⇒
…001110


(ash 7 -1) ⇒ 3
…000111
     ⇒
…000011


(ash -7 1) ⇒ -14
…111001
     ⇒
…110010


(ash -7 -1) ⇒ -4
…111001
     ⇒
…111100
    #+end_src

    以下是左移或右移两位的示例：
    #+begin_src emacs-lisp


			;         binary values
      (ash 5 2)         ;   5  =  …000101
	   ⇒ 20         ;      =  …010100
      (ash -5 2)        ;  -5  =  …111011
	   ⇒ -20        ;      =  …101100

      (ash 5 -2)
	   ⇒ 1          ;      =  …000001

      (ash -5 -2)
	   ⇒ -2         ;      =  …111110
    #+end_src



#+begin_src emacs-lisp
Function: lsh integer1 count
#+end_src

    lsh 是逻辑移位的缩写，它将整数 1 中的位移动到左侧计数位置，或者如果计数为负数则向右移动，将零带入空出的位。  如果 count 是负数，那么 integer1 必须是一个 fixnum 或一个正 bignum，并且 lsh 通过在移位前减去两次 most-negative-fixnum 来将负的 fixnum 视为无符号，从而产生非负结果。  这种古怪的行为可以追溯到 Emacs 仅支持 fixnums 的时候。  如今，灰烬是更好的选择。

    由于 lsh 的行为与 ash 类似，但 integer1 和 count1 均为负数时，以下示例将重点介绍这些例外情况。  这些示例假定使用 30 位的固定编号。

    #+begin_src emacs-lisp
		       ;      binary values
      (ash -7 -1)      ; -7 = …111111111111111111111111111001
	   ⇒ -4        ;    = …111111111111111111111111111100
      (lsh -7 -1)
	   ⇒ 536870908 ;    = …011111111111111111111111111100

      (ash -5 -2)      ; -5 = …111111111111111111111111111011
	   ⇒ -2        ;    = …111111111111111111111111111110
      (lsh -5 -2)
	   ⇒ 268435454 ;    = …001111111111111111111111111110
    #+end_src


#+begin_src emacs-lisp
  Function: logand &rest ints-or-markers
#+end_src
    此函数返回参数的按位与：当且仅当所有参数中的第 n 位为 1 时，结果中的第 n 位为 1。

    例如，使用 4 位二进制数，13 和 12 的按位与为 12：1101 与 1100 组合产生 1100。在这两个二进制数中，最左边的两位都是 1，因此返回值的最左边的两位是两者都是1。但是，对于最右边的两位，至少有一个参数中的每一位都是0，因此返回值的最右边的两位都是0。

    所以，
    #+begin_src emacs-lisp
      (logand 13 12)
	   ⇒ 12
    #+end_src


    如果 logand 未传递任何参数，则返回值 -1。  这个数字是 logand 的标识元素，因为它的二进制表示完全由 1 组成。  如果 logand 只传递了一个参数，它将返回该参数。

    #+begin_src emacs-lisp
			 ;        binary values

      (logand 14 13)     ; 14  =  …001110
			 ; 13  =  …001101
	   ⇒ 12         ; 12  =  …001100


      (logand 14 13 4)   ; 14  =  …001110
			 ; 13  =  …001101
			 ;  4  =  …000100
	   ⇒ 4          ;  4  =  …000100


      (logand)
	   ⇒ -1         ; -1  =  …111111

    #+end_src

#+begin_src emacs-lisp
Function: logior &rest ints-or-markers
#+end_src

    此函数返回其参数的按位或运算：当且仅当至少一个参数中的第 n 位为 1 时，结果中的第 n 位为 1。  如果没有参数，则结果为 0，这是此操作的标识元素。  如果 logior 仅传递一个参数，则返回该参数。

    #+begin_src emacs-lisp


			 ;        binary values

      (logior 12 5)      ; 12  =  …001100
			 ;  5  =  …000101
	   ⇒ 13         ; 13  =  …001101


      (logior 12 5 7)    ; 12  =  …001100
			 ;  5  =  …000101
			 ;  7  =  …000111
	   ⇒ 15         ; 15  =  …001111
    #+end_src


#+begin_src emacs-lisp
Function: logxor &rest ints-or-markers
#+end_src

    此函数返回其参数的按位异或：当且仅当第 n 位在奇数个参数中为 1 时，结果中的第 n 位为 1。  如果没有参数，则结果为 0，这是此操作的标识元素。  如果 logxor 只传递了一个参数，它将返回该参数。

    #+begin_src emacs-lisp
			 ;        binary values

      (logxor 12 5)      ; 12  =  …001100
			 ;  5  =  …000101
	   ⇒ 9          ;  9  =  …001001


      (logxor 12 5 7)    ; 12  =  …001100
			 ;  5  =  …000101
			 ;  7  =  …000111
	   ⇒ 14         ; 14  =  …001110
    #+end_src


#+begin_src emacs-lisp
  Function: lognot integer
#+end_src

    此函数返回其参数的按位补码：当且仅当第 n 位在整数中为零时，结果中的第 n 位为 1，反之亦然。  结果等于 -1 - 整数。
    #+begin_src emacs-lisp
      (lognot 5)
	   ⇒ -6
      ;;  5  =  …000101
      ;; becomes
      ;; -6  =  …111010
    #+end_src



#+begin_src emacs-lisp
  Function: logcount integer
#+end_src

    该函数返回整数的汉明权重：整数的二进制表示中的个数。  如果整数为负数，则返回二进制补码表示中的零位数。  结果总是非负的。
    #+begin_src emacs-lisp
      (logcount 43)     ;  43 = …000101011
	   ⇒ 4
      (logcount -43)    ; -43 = …111010101
	   ⇒ 3
    #+end_src

** DONE 3.9 标准数学函数
  CLOSED: [2022-05-24 Tue 09:54]
  :LOGBOOK:
   - State "DONE"       from "DONE"       [2022-05-24 Tue 09:54]
   :END:

这些数学函数允许整数和浮点数作为参数。

#+begin_src emacs-lisp
  Function: sin arg
#+end_src

#+begin_src emacs-lisp
  Function: cos arg
#+end_src

#+begin_src emacs-lisp
Function: tan arg
#+end_src
    这些是基本的三角函数，参数 arg 以弧度为单位。


#+begin_src emacs-lisp
Function: asin arg
#+end_src

    (asin arg) 的值是介于 -pi/2 和 pi/2（含）之间的数字，其正弦为 arg。  如果 arg 超出范围（在 [-1, 1] 之外），则 asin 返回 NaN。

#+begin_src emacs-lisp
Function: acos arg
#+end_src

    (acos arg) 的值是一个介于 0 和 pi（含）之间的数字，其余弦为 arg。  如果 arg 超出范围（在 [-1, 1] 之外），acos 返回一个 NaN。

#+begin_src emacs-lisp
Function: atan y &optional x
#+end_src

    (atan y) 的值是介于 -pi/2 和 pi/2（不包括）之间的数字，其正切为 y。  如果给定了可选的第二个参数 x，则 (atan yx) 的值是向量 [x, y] 和 X 轴之间的弧度角。

#+begin_src emacs-lisp
Function: exp arg
#+end_src

    这是指数函数；  它将 e 返回到幂 arg。

#+begin_src emacs-lisp
Function: log arg &optional base
#+end_src

    此函数返回 arg 的对数，以底为底。  如果不指定基数，则使用自然基数 e。  如果 arg 或 base 为负数，则 log 返回 NaN。

#+begin_src emacs-lisp
  Function: expt x y
#+end_src

    此函数返回 x 的 y 次幂。  如果两个参数都是整数且 y 为非负数，则结果为整数；  在这种情况下，溢出表示错误，所以要小心。  如果 x 是有限负数且 y 是有限非整数，则 expt 返回 NaN。

#+begin_src emacs-lisp
  Function: sqrt arg
#+end_src
    这将返回 arg 的平方根。  如果 arg 是有限的且小于零，则 sqrt 返回 NaN。

此外，Emacs 还定义了以下常见的数学常数：

#+begin_src emacs-lisp
  Variable: float-e
#+end_src
    数学常数 e (2.71828…)。

#+begin_src emacs-lisp
  Variable: float-pi
#+end_src
    数学常数 pi (3.14159…)。

** DONE 3.10 随机数
  CLOSED: [2022-05-25 Wed 08:36]
  :LOGBOOK:
  :END:
确定性计算机程序无法生成真正的随机数。  对于大多数目的，伪随机数就足够了。  以确定的方式生成一系列伪随机数。  这些数字并不是真正随机的，但它们具有模仿随机序列的某些特性。  例如，所有可能的值在伪随机序列中同样频繁地出现。

伪随机数是从种子值生成的。  从任何给定的种子开始，随机函数总是生成相同的数字序列。  默认情况下，Emacs 在启动时初始化随机种子，这样随机值的序列（具有压倒性的可能性）在每次 Emacs 运行中都不同。

有时您希望随机数序列是可重复的。  例如，在调试行为取决于随机数序列的程序时，在每个程序运行中获得相同的行为是有帮助的。  要使序列重复，请执行（随机“”）。  这会将种子设置为特定 Emacs 可执行文件的常量值（尽管对于其他 Emacs 构建可能会有所不同）。  您可以使用其他字符串来选择各种种子值。

#+begin_src emacs-lisp
  Function: random &optional limit
#+end_src

    此函数返回一个伪随机整数。  重复调用返回一系列伪随机整数。

    如果 limit 是一个正整数，则该值被选择为非负且小于 limit。  否则，该值可能是任何 fixnum，即从 most-negative-fixnum 到 most-positive-fixnum 的任何整数（参见整数基础）。

    如果 limit 是 t，这意味着选择一个新的种子，就像 Emacs 正在重新启动一样，通常来自系统熵。  在缺乏熵池的系统上，从不太随机的易失性数据（例如当前时间）中选择种子。

    如果limit是一个字符串，则意味着根据字符串的内容选择一个新的种子。
