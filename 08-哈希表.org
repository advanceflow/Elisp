* TODO 8 哈希表

哈希表是一种非常快速的查找表，有点像 alist（请参阅关联列表），因为它将键映射到相应的值。它在以下方面与 alist 不同：

    在散列表中查找对于大型表来说非常快——事实上，所需的时间基本上与表中存储了多少元素无关。对于较小的表（几十个元素），alist 可能仍然更快，因为哈希表具有或多或少的恒定开销。
    哈希表中的对应关系没有特定的顺序。
    没有办法在两个哈希表之间共享结构，就像两个 alist 可以共享一个共同的尾部一样。

Emacs Lisp 提供了一种通用的哈希表数据类型，以及一系列对其进行操作的函数。哈希表有一个特殊的打印表示，它由“#s”和一个指定哈希表属性和内容的列表组成。请参阅创建哈希表。（哈希表示法，在没有读取表示的对象的打印表示中使用的初始“#”字符，与哈希表无关。请参阅打印表示和读取语法。）

Obarrays 也是一种哈希表，但它们是不同类型的对象，仅用于记录内部符号（请参阅创建和内部符号）。

** TODO 8.1 创建哈希表

创建哈希表的主要功能是 make-hash-table。

#+begin_src emacs-lisp
  Function: make-hash-table &rest keyword-args ¶
#+end_src


    该函数根据指定的参数创建一个新的哈希表。参数应该由交替的关键字（特别识别的特定符号）和对应的值组成。

    在 make-hash-table 中有几个关键字是有意义的，但你真正需要知道的只有两个是 :test 和 :weakness。

    ：测试一下

	 这指定了此哈希表的键查找方法。默认为 eql；  eq 和 equal 是其他选择：

	 情商

	     如果它们是数字的键，则它们是相同的，也就是说，如果它们的值相等并且两者都是整数或都是浮点数；  否则，两个不同的对象永远不会相同。
	 情商

	     任何两个不同的 Lisp 对象作为键是不同的。
	 平等的

	     两个 Lisp 对象是相同的，作为键，如果它们根据相等是相等的。

	 您可以使用 define-hash-table-test（请参阅定义哈希比较）来定义测试的其他可能性。
    :弱点弱

	 哈希表的弱点指定哈希表中存在的键或值是否会使其免受垃圾收集。

	 弱值必须是 nil、key、value、key-or-value、key-and-value 或 t 之一，它是 key-and-value 的别名。如果弱是键，则哈希表不会阻止其键被作为垃圾收集（如果它们没有在其他任何地方引用）；  如果确实收集了特定的键，则从哈希表中删除相应的关联。

	 如果弱值是值，则哈希表不会阻止值被作为垃圾收集（如果它们没有在其他任何地方引用）；  如果确实收集了特定值，则从哈希表中删除相应的关联。

	 如果 weak 是 key-and-value 或 t，则 key 和 value 都必须处于活动状态才能保持关联。因此，哈希表不保护键或值免受垃圾收集；  如果其中任何一个被作为垃圾收集，则删除关联。

	 如果weak 是key-or-value，则key 或value 都可以保留关联。因此，当关联的键和值都被作为垃圾收集时（如果不是来自弱哈希表的引用），关联就会从哈希表中删除。

	 weak 的默认值是 nil，因此哈希表中引用的所有键和值都不会被垃圾回收。
    :size 大小

	 这指定了您计划在哈希表中存储多少关联的提示。如果您知道大概的数字，您可以通过这种方式指定它来提高效率。如果您指定的大小太小，哈希表会在必要时自动增长，但这样做需要一些额外的时间。

	 默认大小为 65。
    :rehash-size rehash-size

	 当您向哈希表添加关联并且该表已满时，它会自动增长。该值指定当时如何使哈希表变大。

	 如果 rehash-size 是一个整数，它应该是正数，并且哈希表会通过在标称大小上增加大约那么多来增长。如果 rehash-size 是浮点数，它最好大于 1，并且哈希表通过将旧大小乘以大约该数字来增长。

	 默认值为 1.5。
    :rehash-threshold 阈值

	 这指定了哈希表何时满的标准（因此它应该更大）。值 threshold 应该是一个不大于 1 的正浮点数。只要条目的实际数量超过标称大小乘以该值的近似值，哈希表就已满。阈值的默认值为 0.8125。

您还可以使用散列表的打印表示来创建散列表。Lisp 阅读器可以读取此打印表示，前提是指定哈希表中的每个元素都具有有效的读取语法（请参阅打印表示和读取语法）。例如，下面指定了一个哈希表，其中包含分别与 val1（一个符号）和 300（一个数字）相关联的键 key1 和 key2（两个符号）。

#+begin_src emacs-lisp
#s(hash-table size 30 data (key1 val1 key2 300))
#+end_src


但是请注意，当在 Emacs Lisp 代码中使用它时，它是否会创建一个新的哈希表是未定义的。如果你想创建一个新的哈希表，你应该总是使用 make-hash-table（参见自我评估表格）。

哈希表的打印表示由“#s”后跟以“哈希表”开头的列表组成。列表的其余部分应包含零个或多个属性值对，指定哈希表的属性和初始内容。属性和值按字面意思阅读。有效的属性名称是 size、test、weakness、rehash-size、rehash-threshold 和 data。data 属性应该是初始内容的键值对列表；  其他属性与上述匹配的生成哈希表关键字（:size、:test 等）具有相同的含义。

请注意，您不能指定一个哈希表，其初始内容包括没有读取语法的对象，例如缓冲区和帧。此类对象可以在创建后添加到哈希表中。

** TODO 8.2 哈希表访问

本节描述了在哈希表中访问和存储关联的函数。一般来说，任何 Lisp 对象都可以用作散列键，除非比较方法有限制。任何 Lisp 对象也可以用作值。

#+begin_src emacs-lisp
  Function: gethash key table &optional default ¶
#+end_src

    此函数在 table 中查找 key，并返回其关联值 - 或默认值，如果 key 在 table 中没有关联。

#+begin_src emacs-lisp
  Function: puthash key value table ¶
#+end_src

    此函数为表中的键输入关联，并带有值值。如果 key 在 table 中已经有关联，则 value 替换旧的关联 value。

#+begin_src emacs-lisp
  Function: remhash key table ¶
#+end_src

    此函数从表中删除键的关联，如果有的话。如果 key 没有关联，remhash 什么也不做。

    Common Lisp 注意：在 Common Lisp 中，如果 remhash 实际删除了关联，则返回非 nil，否则返回 nil。在 Emacs Lisp 中，remhash 总是返回 nil。

#+begin_src emacs-lisp
  Function: clrhash table ¶
#+end_src

    此函数从哈希表中删除所有关联，使其变为空。这也称为清除哈希表。

    Common Lisp 注意：在 Common Lisp 中，clrhash 返回空表。在 Emacs Lisp 中，它返回 nil。

#+begin_src emacs-lisp
  Function: maphash function table ¶
#+end_src

    该函数为表中的每个关联调用一次函数。函数函数应该接受两个参数——表中列出的键及其关联的值。maphash 返回零。

** TODO 8.3 定义哈希比较

您可以通过 define-hash-table-test 定义新的键查找方法。为了使用此功能，您需要了解哈希表的工作原理以及哈希码的含义。

您可以从概念上将哈希表视为包含许多插槽的大型数组，每个插槽都能够保存一个关联。要查找键，gethash 首先从键中计算一个整数，即哈希码。它可以减少这个整数模数组的长度，以在数组中产生一个索引。然后它在那个槽中查找，如果有必要，在附近的其他槽中查找它是否找到了正在寻找的密钥。

因此，要定义一种新的键查找方法，您需要指定一个从键计算哈希码的函数，以及一个直接比较两个键的函数。这两个函数应该彼此一致：即如果两个键比较相等，则两个键的哈希码应该相同。此外，由于这两个函数可以随时调用（例如由垃圾收集器调用），因此这些函数应该没有副作用并且应该快速返回，并且它们的行为应该只依赖于不改变的键的属性.

#+begin_src emacs-lisp
  Function: define-hash-table-test name test-fn hash-fn ¶
#+end_src

    这个函数定义了一个新的哈希表测试，命名为 name。

    这样定义好name后，就可以在make-hash-table中作为test参数使用了。当您这样做时，哈希表将使用 test-fn 来比较键值，并使用 hash-fn 从键值计算哈希码。

    函数 test-fn 应该接受两个参数，两个键，如果它们被认为是相同的，则返回非零。

    函数 hash-fn 应该接受一个参数，一个键，并返回一个整数，该整数是该键的哈希码。为获得良好的结果，该函数应使用整个范围的固定数字作为哈希码，包括负固定数字。

    指定的函数存储在属性 hash-table-test 下的 name 属性列表中；  属性值的形式是 (test-fn hash-fn)。

#+begin_src emacs-lisp
  Function: sxhash-equal obj ¶
#+end_src

    此函数返回 Lisp 对象 obj 的哈希码。这是一个整数，它反映了 obj 和它指向的其他 Lisp 对象的内容。

    如果两个对象 obj1 和 obj2 相等，那么 (sxhash-equal obj1) 和 (sxhash-equal obj2) 是同一个整数。

    如果两个对象不相等，则 sxhash-equal 返回的值通常不同，但并非总是如此；  偶尔，幸运的是，您会遇到两个外观截然不同的对象，它们从 sxhash-equal 中得到相同的结果。

    Common Lisp 注意：在 Common Lisp 中，一个类似的函数称为 sxhash。Emacs 提供此名称作为 sxhash-equal 的兼容性别名。

#+begin_src emacs-lisp
  Function: sxhash-eq obj ¶
#+end_src

    此函数返回 Lisp 对象 obj 的哈希码。它的结果反映了 obj 的身份，而不是它的内容。

    如果两个对象 obj1 和 obj2 是 eq，那么 (sxhash-eq obj1) 和 (sxhash-eq obj2) 是同一个整数。

#+begin_src emacs-lisp
  Function: sxhash-eql obj ¶
#+end_src

    此函数返回适合 eql 比较的 Lisp 对象 obj 的哈希码。即它反映了 obj 的身份，但对象是 bignum 或浮点数的情况除外，在这种情况下，会为该值生成哈希码。

    如果两个对象 obj1 和 obj2 是 eql，那么 (sxhash-eql obj1) 和 (sxhash-eql obj2) 是同一个整数。

此示例创建一个哈希表，其键是不区分大小写比较的字符串。
#+begin_src emacs-lisp
  (defun case-fold-string= (a b)
    (eq t (compare-strings a nil nil b nil nil t)))
  (defun case-fold-string-hash (a)
    (sxhash-equal (upcase a)))

  (define-hash-table-test 'case-fold
    'case-fold-string= 'case-fold-string-hash)

  (make-hash-table :test 'case-fold)
#+end_src


以下是您如何定义与预定义测试值相等的哈希表测试。键可以是任何 Lisp 对象，并且看起来相同的对象被认为是相同的键。

#+begin_src emacs-lisp
(define-hash-table-test 'contents-hash 'equal 'sxhash-equal)

(make-hash-table :test 'contents-hash)
#+end_src


Lisp 程序不应该依赖在 Emacs 会话之间保留的哈希码，因为哈希函数的实现使用了对象存储的一些细节，这些细节可以在会话之间和不同架构之间改变。

** TODO 8.4 其他哈希表函数

以下是一些用于处理哈希表的其他函数。

#+begin_src emacs-lisp
  Function: hash-table-p table ¶
#+end_src

    如果 table 是哈希表对象，则返回非 nil。

#+begin_src emacs-lisp
  Function: copy-hash-table table ¶
#+end_src

    此函数创建并返回表的副本。只有表本身被复制——键和值是共享的。

#+begin_src emacs-lisp
  Function: hash-table-count table ¶
#+end_src

    此函数返回表中的实际条目数。

#+begin_src emacs-lisp
  Function: hash-table-test table ¶
#+end_src

    这将返回创建表时给出的测试值，以指定如何散列和比较键。请参阅 make-hash-table（请参阅创建哈希表）。

#+begin_src emacs-lisp
  Function: hash-table-weakness table ¶
#+end_src

    此函数返回为哈希表指定的弱值。

#+begin_src emacs-lisp
  Function: hash-table-rehash-size table ¶
#+end_src

    这将返回表的重新散列大小。

#+begin_src emacs-lisp
  Function: hash-table-rehash-threshold table ¶
#+end_src

    这将返回表的重新哈希阈值。

#+begin_src emacs-lisp
  Function: hash-table-size table ¶
#+end_src

    这将返回表的当前标称大小。
